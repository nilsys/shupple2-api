// Code generated by go-enum
// DO NOT EDIT!

package model

import (
	"fmt"
)

const (
	// AccompanyingTypeBUISINESS is a AccompanyingType of type BUISINESS
	AccompanyingTypeBUISINESS AccompanyingType = iota + 1
	// AccompanyingTypeCOUPLE is a AccompanyingType of type COUPLE
	AccompanyingTypeCOUPLE
	// AccompanyingTypeFAMILY is a AccompanyingType of type FAMILY
	AccompanyingTypeFAMILY
	// AccompanyingTypeFRIEND is a AccompanyingType of type FRIEND
	AccompanyingTypeFRIEND
	// AccompanyingTypeONLY is a AccompanyingType of type ONLY
	AccompanyingTypeONLY
	// AccompanyingTypeWITHCHILD is a AccompanyingType of type WITHCHILD
	AccompanyingTypeWITHCHILD
)

const _AccompanyingTypeName = "BUISINESSCOUPLEFAMILYFRIENDONLYWITHCHILD"

var _AccompanyingTypeMap = map[AccompanyingType]string{
	1: _AccompanyingTypeName[0:9],
	2: _AccompanyingTypeName[9:15],
	3: _AccompanyingTypeName[15:21],
	4: _AccompanyingTypeName[21:27],
	5: _AccompanyingTypeName[27:31],
	6: _AccompanyingTypeName[31:40],
}

// String implements the Stringer interface.
func (x AccompanyingType) String() string {
	if str, ok := _AccompanyingTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AccompanyingType(%d)", x)
}

var _AccompanyingTypeValue = map[string]AccompanyingType{
	_AccompanyingTypeName[0:9]:   1,
	_AccompanyingTypeName[9:15]:  2,
	_AccompanyingTypeName[15:21]: 3,
	_AccompanyingTypeName[21:27]: 4,
	_AccompanyingTypeName[27:31]: 5,
	_AccompanyingTypeName[31:40]: 6,
}

// ParseAccompanyingType attempts to convert a string to a AccompanyingType
func ParseAccompanyingType(name string) (AccompanyingType, error) {
	if x, ok := _AccompanyingTypeValue[name]; ok {
		return x, nil
	}
	return AccompanyingType(0), fmt.Errorf("%s is not a valid AccompanyingType", name)
}

// MarshalText implements the text marshaller method
func (x AccompanyingType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AccompanyingType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAccompanyingType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// AreaCategoryTypeUndefined is a AreaCategoryType of type Undefined
	AreaCategoryTypeUndefined AreaCategoryType = iota
	// AreaCategoryTypeArea is a AreaCategoryType of type Area
	AreaCategoryTypeArea
	// AreaCategoryTypeSubArea is a AreaCategoryType of type SubArea
	AreaCategoryTypeSubArea
	// AreaCategoryTypeSubSubArea is a AreaCategoryType of type SubSubArea
	AreaCategoryTypeSubSubArea
)

const _AreaCategoryTypeName = "UndefinedAreaSubAreaSubSubArea"

var _AreaCategoryTypeMap = map[AreaCategoryType]string{
	0: _AreaCategoryTypeName[0:9],
	1: _AreaCategoryTypeName[9:13],
	2: _AreaCategoryTypeName[13:20],
	3: _AreaCategoryTypeName[20:30],
}

// String implements the Stringer interface.
func (x AreaCategoryType) String() string {
	if str, ok := _AreaCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AreaCategoryType(%d)", x)
}

var _AreaCategoryTypeValue = map[string]AreaCategoryType{
	_AreaCategoryTypeName[0:9]:   0,
	_AreaCategoryTypeName[9:13]:  1,
	_AreaCategoryTypeName[13:20]: 2,
	_AreaCategoryTypeName[20:30]: 3,
}

// ParseAreaCategoryType attempts to convert a string to a AreaCategoryType
func ParseAreaCategoryType(name string) (AreaCategoryType, error) {
	if x, ok := _AreaCategoryTypeValue[name]; ok {
		return x, nil
	}
	return AreaCategoryType(0), fmt.Errorf("%s is not a valid AreaCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x AreaCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AreaCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAreaCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// AreaGroupUndefined is a AreaGroup of type Undefined
	AreaGroupUndefined AreaGroup = iota
	// AreaGroupJapan is a AreaGroup of type Japan
	AreaGroupJapan
	// AreaGroupWorld is a AreaGroup of type World
	AreaGroupWorld
)

const _AreaGroupName = "UndefinedJapanWorld"

var _AreaGroupMap = map[AreaGroup]string{
	0: _AreaGroupName[0:9],
	1: _AreaGroupName[9:14],
	2: _AreaGroupName[14:19],
}

// String implements the Stringer interface.
func (x AreaGroup) String() string {
	if str, ok := _AreaGroupMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AreaGroup(%d)", x)
}

var _AreaGroupValue = map[string]AreaGroup{
	_AreaGroupName[0:9]:   0,
	_AreaGroupName[9:14]:  1,
	_AreaGroupName[14:19]: 2,
}

// ParseAreaGroup attempts to convert a string to a AreaGroup
func ParseAreaGroup(name string) (AreaGroup, error) {
	if x, ok := _AreaGroupValue[name]; ok {
		return x, nil
	}
	return AreaGroup(0), fmt.Errorf("%s is not a valid AreaGroup", name)
}

// MarshalText implements the text marshaller method
func (x AreaGroup) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AreaGroup) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAreaGroup(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ContextKeyTransaction is a ContextKey of type Transaction
	ContextKeyTransaction ContextKey = iota + 1
)

const _ContextKeyName = "Transaction"

var _ContextKeyMap = map[ContextKey]string{
	1: _ContextKeyName[0:11],
}

// String implements the Stringer interface.
func (x ContextKey) String() string {
	if str, ok := _ContextKeyMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ContextKey(%d)", x)
}

var _ContextKeyValue = map[string]ContextKey{
	_ContextKeyName[0:11]: 1,
}

// ParseContextKey attempts to convert a string to a ContextKey
func ParseContextKey(name string) (ContextKey, error) {
	if x, ok := _ContextKeyValue[name]; ok {
		return x, nil
	}
	return ContextKey(0), fmt.Errorf("%s is not a valid ContextKey", name)
}

// MarshalText implements the text marshaller method
func (x ContextKey) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ContextKey) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseContextKey(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// GenderMale is a Gender of type Male
	GenderMale Gender = iota + 1
	// GenderFemale is a Gender of type Female
	GenderFemale
)

const _GenderName = "MaleFemale"

var _GenderMap = map[Gender]string{
	1: _GenderName[0:4],
	2: _GenderName[4:10],
}

// String implements the Stringer interface.
func (x Gender) String() string {
	if str, ok := _GenderMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Gender(%d)", x)
}

var _GenderValue = map[string]Gender{
	_GenderName[0:4]:  1,
	_GenderName[4:10]: 2,
}

// ParseGender attempts to convert a string to a Gender
func ParseGender(name string) (Gender, error) {
	if x, ok := _GenderValue[name]; ok {
		return x, nil
	}
	return Gender(0), fmt.Errorf("%s is not a valid Gender", name)
}

// MarshalText implements the text marshaller method
func (x Gender) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *Gender) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseGender(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// InterestGroupUndefined is a InterestGroup of type Undefined
	InterestGroupUndefined InterestGroup = iota
	// InterestGroupStyle is a InterestGroup of type Style
	InterestGroupStyle
	// InterestGroupScene is a InterestGroup of type Scene
	InterestGroupScene
	// InterestGroupGourmet is a InterestGroup of type Gourmet
	InterestGroupGourmet
	// InterestGroupLifeStyle is a InterestGroup of type LifeStyle
	InterestGroupLifeStyle
	// InterestGroupActivity is a InterestGroup of type Activity
	InterestGroupActivity
	// InterestGroupSport is a InterestGroup of type Sport
	InterestGroupSport
)

const _InterestGroupName = "UndefinedStyleSceneGourmetLifeStyleActivitySport"

var _InterestGroupMap = map[InterestGroup]string{
	0: _InterestGroupName[0:9],
	1: _InterestGroupName[9:14],
	2: _InterestGroupName[14:19],
	3: _InterestGroupName[19:26],
	4: _InterestGroupName[26:35],
	5: _InterestGroupName[35:43],
	6: _InterestGroupName[43:48],
}

// String implements the Stringer interface.
func (x InterestGroup) String() string {
	if str, ok := _InterestGroupMap[x]; ok {
		return str
	}
	return fmt.Sprintf("InterestGroup(%d)", x)
}

var _InterestGroupValue = map[string]InterestGroup{
	_InterestGroupName[0:9]:   0,
	_InterestGroupName[9:14]:  1,
	_InterestGroupName[14:19]: 2,
	_InterestGroupName[19:26]: 3,
	_InterestGroupName[26:35]: 4,
	_InterestGroupName[35:43]: 5,
	_InterestGroupName[43:48]: 6,
}

// ParseInterestGroup attempts to convert a string to a InterestGroup
func ParseInterestGroup(name string) (InterestGroup, error) {
	if x, ok := _InterestGroupValue[name]; ok {
		return x, nil
	}
	return InterestGroup(0), fmt.Errorf("%s is not a valid InterestGroup", name)
}

// MarshalText implements the text marshaller method
func (x InterestGroup) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *InterestGroup) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseInterestGroup(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MediaSortByNEW is a MediaSortBy of type NEW
	MediaSortByNEW MediaSortBy = iota + 1
	// MediaSortByRANKING is a MediaSortBy of type RANKING
	MediaSortByRANKING
	// MediaSortByRECOMMEND is a MediaSortBy of type RECOMMEND
	MediaSortByRECOMMEND
)

const _MediaSortByName = "NEWRANKINGRECOMMEND"

var _MediaSortByMap = map[MediaSortBy]string{
	1: _MediaSortByName[0:3],
	2: _MediaSortByName[3:10],
	3: _MediaSortByName[10:19],
}

// String implements the Stringer interface.
func (x MediaSortBy) String() string {
	if str, ok := _MediaSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MediaSortBy(%d)", x)
}

var _MediaSortByValue = map[string]MediaSortBy{
	_MediaSortByName[0:3]:   1,
	_MediaSortByName[3:10]:  2,
	_MediaSortByName[10:19]: 3,
}

// ParseMediaSortBy attempts to convert a string to a MediaSortBy
func ParseMediaSortBy(name string) (MediaSortBy, error) {
	if x, ok := _MediaSortByValue[name]; ok {
		return x, nil
	}
	return MediaSortBy(0), fmt.Errorf("%s is not a valid MediaSortBy", name)
}

// MarshalText implements the text marshaller method
func (x MediaSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *MediaSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMediaSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NoticeActionTargetTypePOST is a NoticeActionTargetType of type POST
	NoticeActionTargetTypePOST NoticeActionTargetType = iota + 1
	// NoticeActionTargetTypeVLOG is a NoticeActionTargetType of type VLOG
	NoticeActionTargetTypeVLOG
	// NoticeActionTargetTypeREVIEW is a NoticeActionTargetType of type REVIEW
	NoticeActionTargetTypeREVIEW
	// NoticeActionTargetTypeCOMMENT is a NoticeActionTargetType of type COMMENT
	NoticeActionTargetTypeCOMMENT
	// NoticeActionTargetTypeREPLY is a NoticeActionTargetType of type REPLY
	NoticeActionTargetTypeREPLY
	// NoticeActionTargetTypeUSER is a NoticeActionTargetType of type USER
	NoticeActionTargetTypeUSER
	// NoticeActionTargetTypeCOMIC is a NoticeActionTargetType of type COMIC
	NoticeActionTargetTypeCOMIC
)

const _NoticeActionTargetTypeName = "POSTVLOGREVIEWCOMMENTREPLYUSERCOMIC"

var _NoticeActionTargetTypeMap = map[NoticeActionTargetType]string{
	1: _NoticeActionTargetTypeName[0:4],
	2: _NoticeActionTargetTypeName[4:8],
	3: _NoticeActionTargetTypeName[8:14],
	4: _NoticeActionTargetTypeName[14:21],
	5: _NoticeActionTargetTypeName[21:26],
	6: _NoticeActionTargetTypeName[26:30],
	7: _NoticeActionTargetTypeName[30:35],
}

// String implements the Stringer interface.
func (x NoticeActionTargetType) String() string {
	if str, ok := _NoticeActionTargetTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoticeActionTargetType(%d)", x)
}

var _NoticeActionTargetTypeValue = map[string]NoticeActionTargetType{
	_NoticeActionTargetTypeName[0:4]:   1,
	_NoticeActionTargetTypeName[4:8]:   2,
	_NoticeActionTargetTypeName[8:14]:  3,
	_NoticeActionTargetTypeName[14:21]: 4,
	_NoticeActionTargetTypeName[21:26]: 5,
	_NoticeActionTargetTypeName[26:30]: 6,
	_NoticeActionTargetTypeName[30:35]: 7,
}

// ParseNoticeActionTargetType attempts to convert a string to a NoticeActionTargetType
func ParseNoticeActionTargetType(name string) (NoticeActionTargetType, error) {
	if x, ok := _NoticeActionTargetTypeValue[name]; ok {
		return x, nil
	}
	return NoticeActionTargetType(0), fmt.Errorf("%s is not a valid NoticeActionTargetType", name)
}

// MarshalText implements the text marshaller method
func (x NoticeActionTargetType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *NoticeActionTargetType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoticeActionTargetType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NoticeActionTypeFAVORITE is a NoticeActionType of type FAVORITE
	NoticeActionTypeFAVORITE NoticeActionType = iota + 1
	// NoticeActionTypeCOMMENT is a NoticeActionType of type COMMENT
	NoticeActionTypeCOMMENT
	// NoticeActionTypeREPLY is a NoticeActionType of type REPLY
	NoticeActionTypeREPLY
	// NoticeActionTypeFOLLOW is a NoticeActionType of type FOLLOW
	NoticeActionTypeFOLLOW
	// NoticeActionTypeTAGGED is a NoticeActionType of type TAGGED
	NoticeActionTypeTAGGED
)

const _NoticeActionTypeName = "FAVORITECOMMENTREPLYFOLLOWTAGGED"

var _NoticeActionTypeMap = map[NoticeActionType]string{
	1: _NoticeActionTypeName[0:8],
	2: _NoticeActionTypeName[8:15],
	3: _NoticeActionTypeName[15:20],
	4: _NoticeActionTypeName[20:26],
	5: _NoticeActionTypeName[26:32],
}

// String implements the Stringer interface.
func (x NoticeActionType) String() string {
	if str, ok := _NoticeActionTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoticeActionType(%d)", x)
}

var _NoticeActionTypeValue = map[string]NoticeActionType{
	_NoticeActionTypeName[0:8]:   1,
	_NoticeActionTypeName[8:15]:  2,
	_NoticeActionTypeName[15:20]: 3,
	_NoticeActionTypeName[20:26]: 4,
	_NoticeActionTypeName[26:32]: 5,
}

// ParseNoticeActionType attempts to convert a string to a NoticeActionType
func ParseNoticeActionType(name string) (NoticeActionType, error) {
	if x, ok := _NoticeActionTypeValue[name]; ok {
		return x, nil
	}
	return NoticeActionType(0), fmt.Errorf("%s is not a valid NoticeActionType", name)
}

// MarshalText implements the text marshaller method
func (x NoticeActionType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *NoticeActionType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoticeActionType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportReasonTypeUNKNOWN is a ReportReasonType of type UNKNOWN
	ReportReasonTypeUNKNOWN ReportReasonType = iota + 1
	// ReportReasonTypeSEXUAL is a ReportReasonType of type SEXUAL
	ReportReasonTypeSEXUAL
	// ReportReasonTypeINAPPROPRIATE is a ReportReasonType of type INAPPROPRIATE
	ReportReasonTypeINAPPROPRIATE
)

const _ReportReasonTypeName = "UNKNOWNSEXUALINAPPROPRIATE"

var _ReportReasonTypeMap = map[ReportReasonType]string{
	1: _ReportReasonTypeName[0:7],
	2: _ReportReasonTypeName[7:13],
	3: _ReportReasonTypeName[13:26],
}

// String implements the Stringer interface.
func (x ReportReasonType) String() string {
	if str, ok := _ReportReasonTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportReasonType(%d)", x)
}

var _ReportReasonTypeValue = map[string]ReportReasonType{
	_ReportReasonTypeName[0:7]:   1,
	_ReportReasonTypeName[7:13]:  2,
	_ReportReasonTypeName[13:26]: 3,
}

// ParseReportReasonType attempts to convert a string to a ReportReasonType
func ParseReportReasonType(name string) (ReportReasonType, error) {
	if x, ok := _ReportReasonTypeValue[name]; ok {
		return x, nil
	}
	return ReportReasonType(0), fmt.Errorf("%s is not a valid ReportReasonType", name)
}

// MarshalText implements the text marshaller method
func (x ReportReasonType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReportReasonType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportReasonType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportTargetTypeREVIEW is a ReportTargetType of type REVIEW
	ReportTargetTypeREVIEW ReportTargetType = iota + 1
	// ReportTargetTypeCOMMENT is a ReportTargetType of type COMMENT
	ReportTargetTypeCOMMENT
	// ReportTargetTypeREPLY is a ReportTargetType of type REPLY
	ReportTargetTypeREPLY
)

const _ReportTargetTypeName = "REVIEWCOMMENTREPLY"

var _ReportTargetTypeMap = map[ReportTargetType]string{
	1: _ReportTargetTypeName[0:6],
	2: _ReportTargetTypeName[6:13],
	3: _ReportTargetTypeName[13:18],
}

// String implements the Stringer interface.
func (x ReportTargetType) String() string {
	if str, ok := _ReportTargetTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportTargetType(%d)", x)
}

var _ReportTargetTypeValue = map[string]ReportTargetType{
	_ReportTargetTypeName[0:6]:   1,
	_ReportTargetTypeName[6:13]:  2,
	_ReportTargetTypeName[13:18]: 3,
}

// ParseReportTargetType attempts to convert a string to a ReportTargetType
func ParseReportTargetType(name string) (ReportTargetType, error) {
	if x, ok := _ReportTargetTypeValue[name]; ok {
		return x, nil
	}
	return ReportTargetType(0), fmt.Errorf("%s is not a valid ReportTargetType", name)
}

// MarshalText implements the text marshaller method
func (x ReportTargetType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReportTargetType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportTargetType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReviewSortByNEW is a ReviewSortBy of type NEW
	ReviewSortByNEW ReviewSortBy = iota + 1
	// ReviewSortByRECOMMEND is a ReviewSortBy of type RECOMMEND
	ReviewSortByRECOMMEND
)

const _ReviewSortByName = "NEWRECOMMEND"

var _ReviewSortByMap = map[ReviewSortBy]string{
	1: _ReviewSortByName[0:3],
	2: _ReviewSortByName[3:12],
}

// String implements the Stringer interface.
func (x ReviewSortBy) String() string {
	if str, ok := _ReviewSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewSortBy(%d)", x)
}

var _ReviewSortByValue = map[string]ReviewSortBy{
	_ReviewSortByName[0:3]:  1,
	_ReviewSortByName[3:12]: 2,
}

// ParseReviewSortBy attempts to convert a string to a ReviewSortBy
func ParseReviewSortBy(name string) (ReviewSortBy, error) {
	if x, ok := _ReviewSortByValue[name]; ok {
		return x, nil
	}
	return ReviewSortBy(0), fmt.Errorf("%s is not a valid ReviewSortBy", name)
}

// MarshalText implements the text marshaller method
func (x ReviewSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReviewSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReviewSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SpotCategoryTypeUndefined is a SpotCategoryType of type Undefined
	SpotCategoryTypeUndefined SpotCategoryType = iota
	// SpotCategoryTypeSpotCategory is a SpotCategoryType of type SpotCategory
	SpotCategoryTypeSpotCategory
	// SpotCategoryTypeSubSpotCategory is a SpotCategoryType of type SubSpotCategory
	SpotCategoryTypeSubSpotCategory
)

const _SpotCategoryTypeName = "UndefinedSpotCategorySubSpotCategory"

var _SpotCategoryTypeMap = map[SpotCategoryType]string{
	0: _SpotCategoryTypeName[0:9],
	1: _SpotCategoryTypeName[9:21],
	2: _SpotCategoryTypeName[21:36],
}

// String implements the Stringer interface.
func (x SpotCategoryType) String() string {
	if str, ok := _SpotCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SpotCategoryType(%d)", x)
}

var _SpotCategoryTypeValue = map[string]SpotCategoryType{
	_SpotCategoryTypeName[0:9]:   0,
	_SpotCategoryTypeName[9:21]:  1,
	_SpotCategoryTypeName[21:36]: 2,
}

// ParseSpotCategoryType attempts to convert a string to a SpotCategoryType
func ParseSpotCategoryType(name string) (SpotCategoryType, error) {
	if x, ok := _SpotCategoryTypeValue[name]; ok {
		return x, nil
	}
	return SpotCategoryType(0), fmt.Errorf("%s is not a valid SpotCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x SpotCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SpotCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSpotCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SuggestionTypeArea is a SuggestionType of type Area
	SuggestionTypeArea SuggestionType = iota + 1
	// SuggestionTypeSubArea is a SuggestionType of type SubArea
	SuggestionTypeSubArea
	// SuggestionTypeSubSubArea is a SuggestionType of type SubSubArea
	SuggestionTypeSubSubArea
	// SuggestionTypeTouristSpot is a SuggestionType of type TouristSpot
	SuggestionTypeTouristSpot
	// SuggestionTypeHashTag is a SuggestionType of type HashTag
	SuggestionTypeHashTag
	// SuggestionTypeUser is a SuggestionType of type User
	SuggestionTypeUser
)

const _SuggestionTypeName = "AreaSubAreaSubSubAreaTouristSpotHashTagUser"

var _SuggestionTypeMap = map[SuggestionType]string{
	1: _SuggestionTypeName[0:4],
	2: _SuggestionTypeName[4:11],
	3: _SuggestionTypeName[11:21],
	4: _SuggestionTypeName[21:32],
	5: _SuggestionTypeName[32:39],
	6: _SuggestionTypeName[39:43],
}

// String implements the Stringer interface.
func (x SuggestionType) String() string {
	if str, ok := _SuggestionTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SuggestionType(%d)", x)
}

var _SuggestionTypeValue = map[string]SuggestionType{
	_SuggestionTypeName[0:4]:   1,
	_SuggestionTypeName[4:11]:  2,
	_SuggestionTypeName[11:21]: 3,
	_SuggestionTypeName[21:32]: 4,
	_SuggestionTypeName[32:39]: 5,
	_SuggestionTypeName[39:43]: 6,
}

// ParseSuggestionType attempts to convert a string to a SuggestionType
func ParseSuggestionType(name string) (SuggestionType, error) {
	if x, ok := _SuggestionTypeValue[name]; ok {
		return x, nil
	}
	return SuggestionType(0), fmt.Errorf("%s is not a valid SuggestionType", name)
}

// MarshalText implements the text marshaller method
func (x SuggestionType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SuggestionType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSuggestionType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ThemeCategoryTypeUndefined is a ThemeCategoryType of type Undefined
	ThemeCategoryTypeUndefined ThemeCategoryType = iota
	// ThemeCategoryTypeTheme is a ThemeCategoryType of type Theme
	ThemeCategoryTypeTheme
	// ThemeCategoryTypeSubTheme is a ThemeCategoryType of type SubTheme
	ThemeCategoryTypeSubTheme
)

const _ThemeCategoryTypeName = "UndefinedThemeSubTheme"

var _ThemeCategoryTypeMap = map[ThemeCategoryType]string{
	0: _ThemeCategoryTypeName[0:9],
	1: _ThemeCategoryTypeName[9:14],
	2: _ThemeCategoryTypeName[14:22],
}

// String implements the Stringer interface.
func (x ThemeCategoryType) String() string {
	if str, ok := _ThemeCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ThemeCategoryType(%d)", x)
}

var _ThemeCategoryTypeValue = map[string]ThemeCategoryType{
	_ThemeCategoryTypeName[0:9]:   0,
	_ThemeCategoryTypeName[9:14]:  1,
	_ThemeCategoryTypeName[14:22]: 2,
}

// ParseThemeCategoryType attempts to convert a string to a ThemeCategoryType
func ParseThemeCategoryType(name string) (ThemeCategoryType, error) {
	if x, ok := _ThemeCategoryTypeValue[name]; ok {
		return x, nil
	}
	return ThemeCategoryType(0), fmt.Errorf("%s is not a valid ThemeCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x ThemeCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ThemeCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseThemeCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserSortByRANKING is a UserSortBy of type RANKING
	UserSortByRANKING UserSortBy = iota + 1
	// UserSortByRECOMMEND is a UserSortBy of type RECOMMEND
	UserSortByRECOMMEND
)

const _UserSortByName = "RANKINGRECOMMEND"

var _UserSortByMap = map[UserSortBy]string{
	1: _UserSortByName[0:7],
	2: _UserSortByName[7:16],
}

// String implements the Stringer interface.
func (x UserSortBy) String() string {
	if str, ok := _UserSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserSortBy(%d)", x)
}

var _UserSortByValue = map[string]UserSortBy{
	_UserSortByName[0:7]:  1,
	_UserSortByName[7:16]: 2,
}

// ParseUserSortBy attempts to convert a string to a UserSortBy
func ParseUserSortBy(name string) (UserSortBy, error) {
	if x, ok := _UserSortByValue[name]; ok {
		return x, nil
	}
	return UserSortBy(0), fmt.Errorf("%s is not a valid UserSortBy", name)
}

// MarshalText implements the text marshaller method
func (x UserSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *UserSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUserSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
