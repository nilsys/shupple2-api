// Code generated by go-enum
// DO NOT EDIT!

package model

import (
	"fmt"
)

const (
	// AccompanyingTypeBUSINESS is a AccompanyingType of type BUSINESS
	AccompanyingTypeBUSINESS AccompanyingType = iota + 1
	// AccompanyingTypeCOUPLE is a AccompanyingType of type COUPLE
	AccompanyingTypeCOUPLE
	// AccompanyingTypeFAMILY is a AccompanyingType of type FAMILY
	AccompanyingTypeFAMILY
	// AccompanyingTypeFRIEND is a AccompanyingType of type FRIEND
	AccompanyingTypeFRIEND
	// AccompanyingTypeONLY is a AccompanyingType of type ONLY
	AccompanyingTypeONLY
	// AccompanyingTypeWITHCHILD is a AccompanyingType of type WITHCHILD
	AccompanyingTypeWITHCHILD
)

const _AccompanyingTypeName = "BUSINESSCOUPLEFAMILYFRIENDONLYWITHCHILD"

var _AccompanyingTypeMap = map[AccompanyingType]string{
	1: _AccompanyingTypeName[0:8],
	2: _AccompanyingTypeName[8:14],
	3: _AccompanyingTypeName[14:20],
	4: _AccompanyingTypeName[20:26],
	5: _AccompanyingTypeName[26:30],
	6: _AccompanyingTypeName[30:39],
}

// String implements the Stringer interface.
func (x AccompanyingType) String() string {
	if str, ok := _AccompanyingTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AccompanyingType(%d)", x)
}

var _AccompanyingTypeValue = map[string]AccompanyingType{
	_AccompanyingTypeName[0:8]:   1,
	_AccompanyingTypeName[8:14]:  2,
	_AccompanyingTypeName[14:20]: 3,
	_AccompanyingTypeName[20:26]: 4,
	_AccompanyingTypeName[26:30]: 5,
	_AccompanyingTypeName[30:39]: 6,
}

// ParseAccompanyingType attempts to convert a string to a AccompanyingType
func ParseAccompanyingType(name string) (AccompanyingType, error) {
	if x, ok := _AccompanyingTypeValue[name]; ok {
		return x, nil
	}
	return AccompanyingType(0), fmt.Errorf("%s is not a valid AccompanyingType", name)
}

// MarshalText implements the text marshaller method
func (x AccompanyingType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AccompanyingType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAccompanyingType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// AreaCategoryTypeUndefined is a AreaCategoryType of type Undefined
	AreaCategoryTypeUndefined AreaCategoryType = iota
	// AreaCategoryTypeArea is a AreaCategoryType of type Area
	AreaCategoryTypeArea
	// AreaCategoryTypeSubArea is a AreaCategoryType of type SubArea
	AreaCategoryTypeSubArea
	// AreaCategoryTypeSubSubArea is a AreaCategoryType of type SubSubArea
	AreaCategoryTypeSubSubArea
)

const _AreaCategoryTypeName = "UndefinedAreaSubAreaSubSubArea"

var _AreaCategoryTypeMap = map[AreaCategoryType]string{
	0: _AreaCategoryTypeName[0:9],
	1: _AreaCategoryTypeName[9:13],
	2: _AreaCategoryTypeName[13:20],
	3: _AreaCategoryTypeName[20:30],
}

// String implements the Stringer interface.
func (x AreaCategoryType) String() string {
	if str, ok := _AreaCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AreaCategoryType(%d)", x)
}

var _AreaCategoryTypeValue = map[string]AreaCategoryType{
	_AreaCategoryTypeName[0:9]:   0,
	_AreaCategoryTypeName[9:13]:  1,
	_AreaCategoryTypeName[13:20]: 2,
	_AreaCategoryTypeName[20:30]: 3,
}

// ParseAreaCategoryType attempts to convert a string to a AreaCategoryType
func ParseAreaCategoryType(name string) (AreaCategoryType, error) {
	if x, ok := _AreaCategoryTypeValue[name]; ok {
		return x, nil
	}
	return AreaCategoryType(0), fmt.Errorf("%s is not a valid AreaCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x AreaCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AreaCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAreaCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// AreaGroupUndefined is a AreaGroup of type Undefined
	AreaGroupUndefined AreaGroup = iota
	// AreaGroupJapan is a AreaGroup of type Japan
	AreaGroupJapan
	// AreaGroupWorld is a AreaGroup of type World
	AreaGroupWorld
)

const _AreaGroupName = "UndefinedJapanWorld"

var _AreaGroupMap = map[AreaGroup]string{
	0: _AreaGroupName[0:9],
	1: _AreaGroupName[9:14],
	2: _AreaGroupName[14:19],
}

// String implements the Stringer interface.
func (x AreaGroup) String() string {
	if str, ok := _AreaGroupMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AreaGroup(%d)", x)
}

var _AreaGroupValue = map[string]AreaGroup{
	_AreaGroupName[0:9]:   0,
	_AreaGroupName[9:14]:  1,
	_AreaGroupName[14:19]: 2,
}

// ParseAreaGroup attempts to convert a string to a AreaGroup
func ParseAreaGroup(name string) (AreaGroup, error) {
	if x, ok := _AreaGroupValue[name]; ok {
		return x, nil
	}
	return AreaGroup(0), fmt.Errorf("%s is not a valid AreaGroup", name)
}

// MarshalText implements the text marshaller method
func (x AreaGroup) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AreaGroup) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAreaGroup(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// CfProjectSortByNew is a CfProjectSortBy of type New
	CfProjectSortByNew CfProjectSortBy = iota
	// CfProjectSortByLargeAmount is a CfProjectSortBy of type LargeAmount
	CfProjectSortByLargeAmount
	// CfProjectSortByPush is a CfProjectSortBy of type Push
	CfProjectSortByPush
	// CfProjectSortByAttention is a CfProjectSortBy of type Attention
	CfProjectSortByAttention
)

const _CfProjectSortByName = "NewLargeAmountPushAttention"

var _CfProjectSortByMap = map[CfProjectSortBy]string{
	0: _CfProjectSortByName[0:3],
	1: _CfProjectSortByName[3:14],
	2: _CfProjectSortByName[14:18],
	3: _CfProjectSortByName[18:27],
}

// String implements the Stringer interface.
func (x CfProjectSortBy) String() string {
	if str, ok := _CfProjectSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CfProjectSortBy(%d)", x)
}

var _CfProjectSortByValue = map[string]CfProjectSortBy{
	_CfProjectSortByName[0:3]:   0,
	_CfProjectSortByName[3:14]:  1,
	_CfProjectSortByName[14:18]: 2,
	_CfProjectSortByName[18:27]: 3,
}

// ParseCfProjectSortBy attempts to convert a string to a CfProjectSortBy
func ParseCfProjectSortBy(name string) (CfProjectSortBy, error) {
	if x, ok := _CfProjectSortByValue[name]; ok {
		return x, nil
	}
	return CfProjectSortBy(0), fmt.Errorf("%s is not a valid CfProjectSortBy", name)
}

// MarshalText implements the text marshaller method
func (x CfProjectSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *CfProjectSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCfProjectSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// CfReturnGiftTypeReservedTicket is a CfReturnGiftType of type ReservedTicket
	CfReturnGiftTypeReservedTicket CfReturnGiftType = iota + 1
	// CfReturnGiftTypeOther is a CfReturnGiftType of type Other
	CfReturnGiftTypeOther
)

const _CfReturnGiftTypeName = "ReservedTicketOther"

var _CfReturnGiftTypeMap = map[CfReturnGiftType]string{
	1: _CfReturnGiftTypeName[0:14],
	2: _CfReturnGiftTypeName[14:19],
}

// String implements the Stringer interface.
func (x CfReturnGiftType) String() string {
	if str, ok := _CfReturnGiftTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CfReturnGiftType(%d)", x)
}

var _CfReturnGiftTypeValue = map[string]CfReturnGiftType{
	_CfReturnGiftTypeName[0:14]:  1,
	_CfReturnGiftTypeName[14:19]: 2,
}

// ParseCfReturnGiftType attempts to convert a string to a CfReturnGiftType
func ParseCfReturnGiftType(name string) (CfReturnGiftType, error) {
	if x, ok := _CfReturnGiftTypeValue[name]; ok {
		return x, nil
	}
	return CfReturnGiftType(0), fmt.Errorf("%s is not a valid CfReturnGiftType", name)
}

// MarshalText implements the text marshaller method
func (x CfReturnGiftType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *CfReturnGiftType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCfReturnGiftType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ContextKeyTransaction is a ContextKey of type Transaction
	ContextKeyTransaction ContextKey = iota + 1
)

const _ContextKeyName = "Transaction"

var _ContextKeyMap = map[ContextKey]string{
	1: _ContextKeyName[0:11],
}

// String implements the Stringer interface.
func (x ContextKey) String() string {
	if str, ok := _ContextKeyMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ContextKey(%d)", x)
}

var _ContextKeyValue = map[string]ContextKey{
	_ContextKeyName[0:11]: 1,
}

// ParseContextKey attempts to convert a string to a ContextKey
func ParseContextKey(name string) (ContextKey, error) {
	if x, ok := _ContextKeyValue[name]; ok {
		return x, nil
	}
	return ContextKey(0), fmt.Errorf("%s is not a valid ContextKey", name)
}

// MarshalText implements the text marshaller method
func (x ContextKey) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ContextKey) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseContextKey(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// GenderUndefined is a Gender of type Undefined
	GenderUndefined Gender = iota
	// GenderMale is a Gender of type Male
	GenderMale
	// GenderFemale is a Gender of type Female
	GenderFemale
)

const _GenderName = "UndefinedMaleFemale"

var _GenderMap = map[Gender]string{
	0: _GenderName[0:9],
	1: _GenderName[9:13],
	2: _GenderName[13:19],
}

// String implements the Stringer interface.
func (x Gender) String() string {
	if str, ok := _GenderMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Gender(%d)", x)
}

var _GenderValue = map[string]Gender{
	_GenderName[0:9]:   0,
	_GenderName[9:13]:  1,
	_GenderName[13:19]: 2,
}

// ParseGender attempts to convert a string to a Gender
func ParseGender(name string) (Gender, error) {
	if x, ok := _GenderValue[name]; ok {
		return x, nil
	}
	return Gender(0), fmt.Errorf("%s is not a valid Gender", name)
}

// MarshalText implements the text marshaller method
func (x Gender) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *Gender) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseGender(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// InterestGroupUndefined is a InterestGroup of type Undefined
	InterestGroupUndefined InterestGroup = iota
	// InterestGroupStyle is a InterestGroup of type Style
	InterestGroupStyle
	// InterestGroupScene is a InterestGroup of type Scene
	InterestGroupScene
	// InterestGroupGourmet is a InterestGroup of type Gourmet
	InterestGroupGourmet
	// InterestGroupLifeStyle is a InterestGroup of type LifeStyle
	InterestGroupLifeStyle
	// InterestGroupActivity is a InterestGroup of type Activity
	InterestGroupActivity
	// InterestGroupSport is a InterestGroup of type Sport
	InterestGroupSport
)

const _InterestGroupName = "UndefinedStyleSceneGourmetLifeStyleActivitySport"

var _InterestGroupMap = map[InterestGroup]string{
	0: _InterestGroupName[0:9],
	1: _InterestGroupName[9:14],
	2: _InterestGroupName[14:19],
	3: _InterestGroupName[19:26],
	4: _InterestGroupName[26:35],
	5: _InterestGroupName[35:43],
	6: _InterestGroupName[43:48],
}

// String implements the Stringer interface.
func (x InterestGroup) String() string {
	if str, ok := _InterestGroupMap[x]; ok {
		return str
	}
	return fmt.Sprintf("InterestGroup(%d)", x)
}

var _InterestGroupValue = map[string]InterestGroup{
	_InterestGroupName[0:9]:   0,
	_InterestGroupName[9:14]:  1,
	_InterestGroupName[14:19]: 2,
	_InterestGroupName[19:26]: 3,
	_InterestGroupName[26:35]: 4,
	_InterestGroupName[35:43]: 5,
	_InterestGroupName[43:48]: 6,
}

// ParseInterestGroup attempts to convert a string to a InterestGroup
func ParseInterestGroup(name string) (InterestGroup, error) {
	if x, ok := _InterestGroupValue[name]; ok {
		return x, nil
	}
	return InterestGroup(0), fmt.Errorf("%s is not a valid InterestGroup", name)
}

// MarshalText implements the text marshaller method
func (x InterestGroup) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *InterestGroup) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseInterestGroup(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MailTemplateNameThanksPurchase is a MailTemplateName of type ThanksPurchase
	MailTemplateNameThanksPurchase MailTemplateName = iota + 1
	// MailTemplateNameReserveRequestForOwner is a MailTemplateName of type ReserveRequestForOwner
	MailTemplateNameReserveRequestForOwner
	// MailTemplateNameCfProjectAchievementNoticeForSupporter is a MailTemplateName of type CfProjectAchievementNoticeForSupporter
	MailTemplateNameCfProjectAchievementNoticeForSupporter
	// MailTemplateNameCfProjectPostNewReportNoticeForSupporter is a MailTemplateName of type CfProjectPostNewReportNoticeForSupporter
	MailTemplateNameCfProjectPostNewReportNoticeForSupporter
)

const _MailTemplateNameName = "ThanksPurchaseReserveRequestForOwnerCfProjectAchievementNoticeForSupporterCfProjectPostNewReportNoticeForSupporter"

var _MailTemplateNameMap = map[MailTemplateName]string{
	1: _MailTemplateNameName[0:14],
	2: _MailTemplateNameName[14:36],
	3: _MailTemplateNameName[36:74],
	4: _MailTemplateNameName[74:114],
}

// String implements the Stringer interface.
func (x MailTemplateName) String() string {
	if str, ok := _MailTemplateNameMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MailTemplateName(%d)", x)
}

var _MailTemplateNameValue = map[string]MailTemplateName{
	_MailTemplateNameName[0:14]:   1,
	_MailTemplateNameName[14:36]:  2,
	_MailTemplateNameName[36:74]:  3,
	_MailTemplateNameName[74:114]: 4,
}

// ParseMailTemplateName attempts to convert a string to a MailTemplateName
func ParseMailTemplateName(name string) (MailTemplateName, error) {
	if x, ok := _MailTemplateNameValue[name]; ok {
		return x, nil
	}
	return MailTemplateName(0), fmt.Errorf("%s is not a valid MailTemplateName", name)
}

// MarshalText implements the text marshaller method
func (x MailTemplateName) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *MailTemplateName) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMailTemplateName(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MediaSortByNEW is a MediaSortBy of type NEW
	MediaSortByNEW MediaSortBy = iota + 1
	// MediaSortByRANKING is a MediaSortBy of type RANKING
	MediaSortByRANKING
	// MediaSortByRECOMMEND is a MediaSortBy of type RECOMMEND
	MediaSortByRECOMMEND
)

const _MediaSortByName = "NEWRANKINGRECOMMEND"

var _MediaSortByMap = map[MediaSortBy]string{
	1: _MediaSortByName[0:3],
	2: _MediaSortByName[3:10],
	3: _MediaSortByName[10:19],
}

// String implements the Stringer interface.
func (x MediaSortBy) String() string {
	if str, ok := _MediaSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MediaSortBy(%d)", x)
}

var _MediaSortByValue = map[string]MediaSortBy{
	_MediaSortByName[0:3]:   1,
	_MediaSortByName[3:10]:  2,
	_MediaSortByName[10:19]: 3,
}

// ParseMediaSortBy attempts to convert a string to a MediaSortBy
func ParseMediaSortBy(name string) (MediaSortBy, error) {
	if x, ok := _MediaSortByValue[name]; ok {
		return x, nil
	}
	return MediaSortBy(0), fmt.Errorf("%s is not a valid MediaSortBy", name)
}

// MarshalText implements the text marshaller method
func (x MediaSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *MediaSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMediaSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NoticeActionTargetTypePOST is a NoticeActionTargetType of type POST
	NoticeActionTargetTypePOST NoticeActionTargetType = iota + 1
	// NoticeActionTargetTypeVLOG is a NoticeActionTargetType of type VLOG
	NoticeActionTargetTypeVLOG
	// NoticeActionTargetTypeREVIEW is a NoticeActionTargetType of type REVIEW
	NoticeActionTargetTypeREVIEW
	// NoticeActionTargetTypeCOMMENT is a NoticeActionTargetType of type COMMENT
	NoticeActionTargetTypeCOMMENT
	// NoticeActionTargetTypeREPLY is a NoticeActionTargetType of type REPLY
	NoticeActionTargetTypeREPLY
	// NoticeActionTargetTypeUSER is a NoticeActionTargetType of type USER
	NoticeActionTargetTypeUSER
	// NoticeActionTargetTypeCOMIC is a NoticeActionTargetType of type COMIC
	NoticeActionTargetTypeCOMIC
)

const _NoticeActionTargetTypeName = "POSTVLOGREVIEWCOMMENTREPLYUSERCOMIC"

var _NoticeActionTargetTypeMap = map[NoticeActionTargetType]string{
	1: _NoticeActionTargetTypeName[0:4],
	2: _NoticeActionTargetTypeName[4:8],
	3: _NoticeActionTargetTypeName[8:14],
	4: _NoticeActionTargetTypeName[14:21],
	5: _NoticeActionTargetTypeName[21:26],
	6: _NoticeActionTargetTypeName[26:30],
	7: _NoticeActionTargetTypeName[30:35],
}

// String implements the Stringer interface.
func (x NoticeActionTargetType) String() string {
	if str, ok := _NoticeActionTargetTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoticeActionTargetType(%d)", x)
}

var _NoticeActionTargetTypeValue = map[string]NoticeActionTargetType{
	_NoticeActionTargetTypeName[0:4]:   1,
	_NoticeActionTargetTypeName[4:8]:   2,
	_NoticeActionTargetTypeName[8:14]:  3,
	_NoticeActionTargetTypeName[14:21]: 4,
	_NoticeActionTargetTypeName[21:26]: 5,
	_NoticeActionTargetTypeName[26:30]: 6,
	_NoticeActionTargetTypeName[30:35]: 7,
}

// ParseNoticeActionTargetType attempts to convert a string to a NoticeActionTargetType
func ParseNoticeActionTargetType(name string) (NoticeActionTargetType, error) {
	if x, ok := _NoticeActionTargetTypeValue[name]; ok {
		return x, nil
	}
	return NoticeActionTargetType(0), fmt.Errorf("%s is not a valid NoticeActionTargetType", name)
}

// MarshalText implements the text marshaller method
func (x NoticeActionTargetType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *NoticeActionTargetType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoticeActionTargetType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NoticeActionTypeFAVORITE is a NoticeActionType of type FAVORITE
	NoticeActionTypeFAVORITE NoticeActionType = iota + 1
	// NoticeActionTypeCOMMENT is a NoticeActionType of type COMMENT
	NoticeActionTypeCOMMENT
	// NoticeActionTypeREPLY is a NoticeActionType of type REPLY
	NoticeActionTypeREPLY
	// NoticeActionTypeFOLLOW is a NoticeActionType of type FOLLOW
	NoticeActionTypeFOLLOW
	// NoticeActionTypeTAGGED is a NoticeActionType of type TAGGED
	NoticeActionTypeTAGGED
)

const _NoticeActionTypeName = "FAVORITECOMMENTREPLYFOLLOWTAGGED"

var _NoticeActionTypeMap = map[NoticeActionType]string{
	1: _NoticeActionTypeName[0:8],
	2: _NoticeActionTypeName[8:15],
	3: _NoticeActionTypeName[15:20],
	4: _NoticeActionTypeName[20:26],
	5: _NoticeActionTypeName[26:32],
}

// String implements the Stringer interface.
func (x NoticeActionType) String() string {
	if str, ok := _NoticeActionTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoticeActionType(%d)", x)
}

var _NoticeActionTypeValue = map[string]NoticeActionType{
	_NoticeActionTypeName[0:8]:   1,
	_NoticeActionTypeName[8:15]:  2,
	_NoticeActionTypeName[15:20]: 3,
	_NoticeActionTypeName[20:26]: 4,
	_NoticeActionTypeName[26:32]: 5,
}

// ParseNoticeActionType attempts to convert a string to a NoticeActionType
func ParseNoticeActionType(name string) (NoticeActionType, error) {
	if x, ok := _NoticeActionTypeValue[name]; ok {
		return x, nil
	}
	return NoticeActionType(0), fmt.Errorf("%s is not a valid NoticeActionType", name)
}

// MarshalText implements the text marshaller method
func (x NoticeActionType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *NoticeActionType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoticeActionType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// PaymentCfReturnGiftOtherTypeStatusUndefined is a PaymentCfReturnGiftOtherTypeStatus of type Undefined
	PaymentCfReturnGiftOtherTypeStatusUndefined PaymentCfReturnGiftOtherTypeStatus = iota
	// PaymentCfReturnGiftOtherTypeStatusOwnerUnconfirmed is a PaymentCfReturnGiftOtherTypeStatus of type OwnerUnconfirmed
	PaymentCfReturnGiftOtherTypeStatusOwnerUnconfirmed
	// PaymentCfReturnGiftOtherTypeStatusOwnerConfirmed is a PaymentCfReturnGiftOtherTypeStatus of type OwnerConfirmed
	PaymentCfReturnGiftOtherTypeStatusOwnerConfirmed
	// PaymentCfReturnGiftOtherTypeStatusCanceled is a PaymentCfReturnGiftOtherTypeStatus of type Canceled
	PaymentCfReturnGiftOtherTypeStatusCanceled
)

const _PaymentCfReturnGiftOtherTypeStatusName = "UndefinedOwnerUnconfirmedOwnerConfirmedCanceled"

var _PaymentCfReturnGiftOtherTypeStatusMap = map[PaymentCfReturnGiftOtherTypeStatus]string{
	0: _PaymentCfReturnGiftOtherTypeStatusName[0:9],
	1: _PaymentCfReturnGiftOtherTypeStatusName[9:25],
	2: _PaymentCfReturnGiftOtherTypeStatusName[25:39],
	3: _PaymentCfReturnGiftOtherTypeStatusName[39:47],
}

// String implements the Stringer interface.
func (x PaymentCfReturnGiftOtherTypeStatus) String() string {
	if str, ok := _PaymentCfReturnGiftOtherTypeStatusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PaymentCfReturnGiftOtherTypeStatus(%d)", x)
}

var _PaymentCfReturnGiftOtherTypeStatusValue = map[string]PaymentCfReturnGiftOtherTypeStatus{
	_PaymentCfReturnGiftOtherTypeStatusName[0:9]:   0,
	_PaymentCfReturnGiftOtherTypeStatusName[9:25]:  1,
	_PaymentCfReturnGiftOtherTypeStatusName[25:39]: 2,
	_PaymentCfReturnGiftOtherTypeStatusName[39:47]: 3,
}

// ParsePaymentCfReturnGiftOtherTypeStatus attempts to convert a string to a PaymentCfReturnGiftOtherTypeStatus
func ParsePaymentCfReturnGiftOtherTypeStatus(name string) (PaymentCfReturnGiftOtherTypeStatus, error) {
	if x, ok := _PaymentCfReturnGiftOtherTypeStatusValue[name]; ok {
		return x, nil
	}
	return PaymentCfReturnGiftOtherTypeStatus(0), fmt.Errorf("%s is not a valid PaymentCfReturnGiftOtherTypeStatus", name)
}

// MarshalText implements the text marshaller method
func (x PaymentCfReturnGiftOtherTypeStatus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *PaymentCfReturnGiftOtherTypeStatus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePaymentCfReturnGiftOtherTypeStatus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// PaymentCfReturnGiftReservedTicketTypeStatusUndefined is a PaymentCfReturnGiftReservedTicketTypeStatus of type Undefined
	PaymentCfReturnGiftReservedTicketTypeStatusUndefined PaymentCfReturnGiftReservedTicketTypeStatus = iota
	// PaymentCfReturnGiftReservedTicketTypeStatusUnreserved is a PaymentCfReturnGiftReservedTicketTypeStatus of type Unreserved
	PaymentCfReturnGiftReservedTicketTypeStatusUnreserved
	// PaymentCfReturnGiftReservedTicketTypeStatusReserved is a PaymentCfReturnGiftReservedTicketTypeStatus of type Reserved
	PaymentCfReturnGiftReservedTicketTypeStatusReserved
)

const _PaymentCfReturnGiftReservedTicketTypeStatusName = "UndefinedUnreservedReserved"

var _PaymentCfReturnGiftReservedTicketTypeStatusMap = map[PaymentCfReturnGiftReservedTicketTypeStatus]string{
	0: _PaymentCfReturnGiftReservedTicketTypeStatusName[0:9],
	1: _PaymentCfReturnGiftReservedTicketTypeStatusName[9:19],
	2: _PaymentCfReturnGiftReservedTicketTypeStatusName[19:27],
}

// String implements the Stringer interface.
func (x PaymentCfReturnGiftReservedTicketTypeStatus) String() string {
	if str, ok := _PaymentCfReturnGiftReservedTicketTypeStatusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PaymentCfReturnGiftReservedTicketTypeStatus(%d)", x)
}

var _PaymentCfReturnGiftReservedTicketTypeStatusValue = map[string]PaymentCfReturnGiftReservedTicketTypeStatus{
	_PaymentCfReturnGiftReservedTicketTypeStatusName[0:9]:   0,
	_PaymentCfReturnGiftReservedTicketTypeStatusName[9:19]:  1,
	_PaymentCfReturnGiftReservedTicketTypeStatusName[19:27]: 2,
}

// ParsePaymentCfReturnGiftReservedTicketTypeStatus attempts to convert a string to a PaymentCfReturnGiftReservedTicketTypeStatus
func ParsePaymentCfReturnGiftReservedTicketTypeStatus(name string) (PaymentCfReturnGiftReservedTicketTypeStatus, error) {
	if x, ok := _PaymentCfReturnGiftReservedTicketTypeStatusValue[name]; ok {
		return x, nil
	}
	return PaymentCfReturnGiftReservedTicketTypeStatus(0), fmt.Errorf("%s is not a valid PaymentCfReturnGiftReservedTicketTypeStatus", name)
}

// MarshalText implements the text marshaller method
func (x PaymentCfReturnGiftReservedTicketTypeStatus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *PaymentCfReturnGiftReservedTicketTypeStatus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePaymentCfReturnGiftReservedTicketTypeStatus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportReasonTypeUNKNOWN is a ReportReasonType of type UNKNOWN
	ReportReasonTypeUNKNOWN ReportReasonType = iota + 1
	// ReportReasonTypeSEXUAL is a ReportReasonType of type SEXUAL
	ReportReasonTypeSEXUAL
	// ReportReasonTypeINAPPROPRIATE is a ReportReasonType of type INAPPROPRIATE
	ReportReasonTypeINAPPROPRIATE
	// ReportReasonTypeCOPYRIGHT is a ReportReasonType of type COPYRIGHT
	ReportReasonTypeCOPYRIGHT
	// ReportReasonTypeSELFHARM is a ReportReasonType of type SELFHARM
	ReportReasonTypeSELFHARM
	// ReportReasonTypeLIE is a ReportReasonType of type LIE
	ReportReasonTypeLIE
	// ReportReasonTypeUNRELATED is a ReportReasonType of type UNRELATED
	ReportReasonTypeUNRELATED
	// ReportReasonTypeAD is a ReportReasonType of type AD
	ReportReasonTypeAD
)

const _ReportReasonTypeName = "UNKNOWNSEXUALINAPPROPRIATECOPYRIGHTSELFHARMLIEUNRELATEDAD"

var _ReportReasonTypeMap = map[ReportReasonType]string{
	1: _ReportReasonTypeName[0:7],
	2: _ReportReasonTypeName[7:13],
	3: _ReportReasonTypeName[13:26],
	4: _ReportReasonTypeName[26:35],
	5: _ReportReasonTypeName[35:43],
	6: _ReportReasonTypeName[43:46],
	7: _ReportReasonTypeName[46:55],
	8: _ReportReasonTypeName[55:57],
}

// String implements the Stringer interface.
func (x ReportReasonType) String() string {
	if str, ok := _ReportReasonTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportReasonType(%d)", x)
}

var _ReportReasonTypeValue = map[string]ReportReasonType{
	_ReportReasonTypeName[0:7]:   1,
	_ReportReasonTypeName[7:13]:  2,
	_ReportReasonTypeName[13:26]: 3,
	_ReportReasonTypeName[26:35]: 4,
	_ReportReasonTypeName[35:43]: 5,
	_ReportReasonTypeName[43:46]: 6,
	_ReportReasonTypeName[46:55]: 7,
	_ReportReasonTypeName[55:57]: 8,
}

// ParseReportReasonType attempts to convert a string to a ReportReasonType
func ParseReportReasonType(name string) (ReportReasonType, error) {
	if x, ok := _ReportReasonTypeValue[name]; ok {
		return x, nil
	}
	return ReportReasonType(0), fmt.Errorf("%s is not a valid ReportReasonType", name)
}

// MarshalText implements the text marshaller method
func (x ReportReasonType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReportReasonType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportReasonType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportTargetTypeREVIEW is a ReportTargetType of type REVIEW
	ReportTargetTypeREVIEW ReportTargetType = iota + 1
	// ReportTargetTypeCOMMENT is a ReportTargetType of type COMMENT
	ReportTargetTypeCOMMENT
	// ReportTargetTypeREPLY is a ReportTargetType of type REPLY
	ReportTargetTypeREPLY
)

const _ReportTargetTypeName = "REVIEWCOMMENTREPLY"

var _ReportTargetTypeMap = map[ReportTargetType]string{
	1: _ReportTargetTypeName[0:6],
	2: _ReportTargetTypeName[6:13],
	3: _ReportTargetTypeName[13:18],
}

// String implements the Stringer interface.
func (x ReportTargetType) String() string {
	if str, ok := _ReportTargetTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportTargetType(%d)", x)
}

var _ReportTargetTypeValue = map[string]ReportTargetType{
	_ReportTargetTypeName[0:6]:   1,
	_ReportTargetTypeName[6:13]:  2,
	_ReportTargetTypeName[13:18]: 3,
}

// ParseReportTargetType attempts to convert a string to a ReportTargetType
func ParseReportTargetType(name string) (ReportTargetType, error) {
	if x, ok := _ReportTargetTypeValue[name]; ok {
		return x, nil
	}
	return ReportTargetType(0), fmt.Errorf("%s is not a valid ReportTargetType", name)
}

// MarshalText implements the text marshaller method
func (x ReportTargetType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReportTargetType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportTargetType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReviewSortByNEW is a ReviewSortBy of type NEW
	ReviewSortByNEW ReviewSortBy = iota + 1
	// ReviewSortByRECOMMEND is a ReviewSortBy of type RECOMMEND
	ReviewSortByRECOMMEND
)

const _ReviewSortByName = "NEWRECOMMEND"

var _ReviewSortByMap = map[ReviewSortBy]string{
	1: _ReviewSortByName[0:3],
	2: _ReviewSortByName[3:12],
}

// String implements the Stringer interface.
func (x ReviewSortBy) String() string {
	if str, ok := _ReviewSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewSortBy(%d)", x)
}

var _ReviewSortByValue = map[string]ReviewSortBy{
	_ReviewSortByName[0:3]:  1,
	_ReviewSortByName[3:12]: 2,
}

// ParseReviewSortBy attempts to convert a string to a ReviewSortBy
func ParseReviewSortBy(name string) (ReviewSortBy, error) {
	if x, ok := _ReviewSortByValue[name]; ok {
		return x, nil
	}
	return ReviewSortBy(0), fmt.Errorf("%s is not a valid ReviewSortBy", name)
}

// MarshalText implements the text marshaller method
func (x ReviewSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReviewSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReviewSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SpotCategoryTypeUndefined is a SpotCategoryType of type Undefined
	SpotCategoryTypeUndefined SpotCategoryType = iota
	// SpotCategoryTypeSpotCategory is a SpotCategoryType of type SpotCategory
	SpotCategoryTypeSpotCategory
	// SpotCategoryTypeSubSpotCategory is a SpotCategoryType of type SubSpotCategory
	SpotCategoryTypeSubSpotCategory
)

const _SpotCategoryTypeName = "UndefinedSpotCategorySubSpotCategory"

var _SpotCategoryTypeMap = map[SpotCategoryType]string{
	0: _SpotCategoryTypeName[0:9],
	1: _SpotCategoryTypeName[9:21],
	2: _SpotCategoryTypeName[21:36],
}

// String implements the Stringer interface.
func (x SpotCategoryType) String() string {
	if str, ok := _SpotCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SpotCategoryType(%d)", x)
}

var _SpotCategoryTypeValue = map[string]SpotCategoryType{
	_SpotCategoryTypeName[0:9]:   0,
	_SpotCategoryTypeName[9:21]:  1,
	_SpotCategoryTypeName[21:36]: 2,
}

// ParseSpotCategoryType attempts to convert a string to a SpotCategoryType
func ParseSpotCategoryType(name string) (SpotCategoryType, error) {
	if x, ok := _SpotCategoryTypeValue[name]; ok {
		return x, nil
	}
	return SpotCategoryType(0), fmt.Errorf("%s is not a valid SpotCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x SpotCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SpotCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSpotCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SuggestionTypeArea is a SuggestionType of type Area
	SuggestionTypeArea SuggestionType = iota + 1
	// SuggestionTypeSubArea is a SuggestionType of type SubArea
	SuggestionTypeSubArea
	// SuggestionTypeSubSubArea is a SuggestionType of type SubSubArea
	SuggestionTypeSubSubArea
	// SuggestionTypeTouristSpot is a SuggestionType of type TouristSpot
	SuggestionTypeTouristSpot
	// SuggestionTypeHashTag is a SuggestionType of type HashTag
	SuggestionTypeHashTag
	// SuggestionTypeUser is a SuggestionType of type User
	SuggestionTypeUser
)

const _SuggestionTypeName = "AreaSubAreaSubSubAreaTouristSpotHashTagUser"

var _SuggestionTypeMap = map[SuggestionType]string{
	1: _SuggestionTypeName[0:4],
	2: _SuggestionTypeName[4:11],
	3: _SuggestionTypeName[11:21],
	4: _SuggestionTypeName[21:32],
	5: _SuggestionTypeName[32:39],
	6: _SuggestionTypeName[39:43],
}

// String implements the Stringer interface.
func (x SuggestionType) String() string {
	if str, ok := _SuggestionTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SuggestionType(%d)", x)
}

var _SuggestionTypeValue = map[string]SuggestionType{
	_SuggestionTypeName[0:4]:   1,
	_SuggestionTypeName[4:11]:  2,
	_SuggestionTypeName[11:21]: 3,
	_SuggestionTypeName[21:32]: 4,
	_SuggestionTypeName[32:39]: 5,
	_SuggestionTypeName[39:43]: 6,
}

// ParseSuggestionType attempts to convert a string to a SuggestionType
func ParseSuggestionType(name string) (SuggestionType, error) {
	if x, ok := _SuggestionTypeValue[name]; ok {
		return x, nil
	}
	return SuggestionType(0), fmt.Errorf("%s is not a valid SuggestionType", name)
}

// MarshalText implements the text marshaller method
func (x SuggestionType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SuggestionType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSuggestionType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ThemeCategoryTypeUndefined is a ThemeCategoryType of type Undefined
	ThemeCategoryTypeUndefined ThemeCategoryType = iota
	// ThemeCategoryTypeTheme is a ThemeCategoryType of type Theme
	ThemeCategoryTypeTheme
	// ThemeCategoryTypeSubTheme is a ThemeCategoryType of type SubTheme
	ThemeCategoryTypeSubTheme
)

const _ThemeCategoryTypeName = "UndefinedThemeSubTheme"

var _ThemeCategoryTypeMap = map[ThemeCategoryType]string{
	0: _ThemeCategoryTypeName[0:9],
	1: _ThemeCategoryTypeName[9:14],
	2: _ThemeCategoryTypeName[14:22],
}

// String implements the Stringer interface.
func (x ThemeCategoryType) String() string {
	if str, ok := _ThemeCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ThemeCategoryType(%d)", x)
}

var _ThemeCategoryTypeValue = map[string]ThemeCategoryType{
	_ThemeCategoryTypeName[0:9]:   0,
	_ThemeCategoryTypeName[9:14]:  1,
	_ThemeCategoryTypeName[14:22]: 2,
}

// ParseThemeCategoryType attempts to convert a string to a ThemeCategoryType
func ParseThemeCategoryType(name string) (ThemeCategoryType, error) {
	if x, ok := _ThemeCategoryTypeValue[name]; ok {
		return x, nil
	}
	return ThemeCategoryType(0), fmt.Errorf("%s is not a valid ThemeCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x ThemeCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ThemeCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseThemeCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserAttributeCommon is a UserAttribute of type Common
	UserAttributeCommon UserAttribute = iota + 1
	// UserAttributeWP is a UserAttribute of type WP
	UserAttributeWP
	// UserAttributeCfProjectOwner is a UserAttribute of type CfProjectOwner
	UserAttributeCfProjectOwner
)

const _UserAttributeName = "CommonWPCfProjectOwner"

var _UserAttributeMap = map[UserAttribute]string{
	1: _UserAttributeName[0:6],
	2: _UserAttributeName[6:8],
	3: _UserAttributeName[8:22],
}

// String implements the Stringer interface.
func (x UserAttribute) String() string {
	if str, ok := _UserAttributeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserAttribute(%d)", x)
}

var _UserAttributeValue = map[string]UserAttribute{
	_UserAttributeName[0:6]:  1,
	_UserAttributeName[6:8]:  2,
	_UserAttributeName[8:22]: 3,
}

// ParseUserAttribute attempts to convert a string to a UserAttribute
func ParseUserAttribute(name string) (UserAttribute, error) {
	if x, ok := _UserAttributeValue[name]; ok {
		return x, nil
	}
	return UserAttribute(0), fmt.Errorf("%s is not a valid UserAttribute", name)
}

// MarshalText implements the text marshaller method
func (x UserAttribute) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *UserAttribute) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUserAttribute(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserSortByRANKING is a UserSortBy of type RANKING
	UserSortByRANKING UserSortBy = iota + 1
	// UserSortByRECOMMEND is a UserSortBy of type RECOMMEND
	UserSortByRECOMMEND
)

const _UserSortByName = "RANKINGRECOMMEND"

var _UserSortByMap = map[UserSortBy]string{
	1: _UserSortByName[0:7],
	2: _UserSortByName[7:16],
}

// String implements the Stringer interface.
func (x UserSortBy) String() string {
	if str, ok := _UserSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserSortBy(%d)", x)
}

var _UserSortByValue = map[string]UserSortBy{
	_UserSortByName[0:7]:  1,
	_UserSortByName[7:16]: 2,
}

// ParseUserSortBy attempts to convert a string to a UserSortBy
func ParseUserSortBy(name string) (UserSortBy, error) {
	if x, ok := _UserSortByValue[name]; ok {
		return x, nil
	}
	return UserSortBy(0), fmt.Errorf("%s is not a valid UserSortBy", name)
}

// MarshalText implements the text marshaller method
func (x UserSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *UserSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUserSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
