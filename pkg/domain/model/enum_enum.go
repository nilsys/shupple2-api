// Code generated by go-enum
// DO NOT EDIT!

package model

import (
	"fmt"
)

const (
	// AccompanyingTypeBUISINESS is a AccompanyingType of type BUISINESS
	AccompanyingTypeBUISINESS AccompanyingType = iota + 1
	// AccompanyingTypeCOUPLE is a AccompanyingType of type COUPLE
	AccompanyingTypeCOUPLE
	// AccompanyingTypeFAMILY is a AccompanyingType of type FAMILY
	AccompanyingTypeFAMILY
	// AccompanyingTypeFRIEND is a AccompanyingType of type FRIEND
	AccompanyingTypeFRIEND
	// AccompanyingTypeONLY is a AccompanyingType of type ONLY
	AccompanyingTypeONLY
	// AccompanyingTypeWITHCHILD is a AccompanyingType of type WITHCHILD
	AccompanyingTypeWITHCHILD
)

const _AccompanyingTypeName = "BUISINESSCOUPLEFAMILYFRIENDONLYWITHCHILD"

var _AccompanyingTypeMap = map[AccompanyingType]string{
	1: _AccompanyingTypeName[0:9],
	2: _AccompanyingTypeName[9:15],
	3: _AccompanyingTypeName[15:21],
	4: _AccompanyingTypeName[21:27],
	5: _AccompanyingTypeName[27:31],
	6: _AccompanyingTypeName[31:40],
}

// String implements the Stringer interface.
func (x AccompanyingType) String() string {
	if str, ok := _AccompanyingTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AccompanyingType(%d)", x)
}

var _AccompanyingTypeValue = map[string]AccompanyingType{
	_AccompanyingTypeName[0:9]:   1,
	_AccompanyingTypeName[9:15]:  2,
	_AccompanyingTypeName[15:21]: 3,
	_AccompanyingTypeName[21:27]: 4,
	_AccompanyingTypeName[27:31]: 5,
	_AccompanyingTypeName[31:40]: 6,
}

// ParseAccompanyingType attempts to convert a string to a AccompanyingType
func ParseAccompanyingType(name string) (AccompanyingType, error) {
	if x, ok := _AccompanyingTypeValue[name]; ok {
		return x, nil
	}
	return AccompanyingType(0), fmt.Errorf("%s is not a valid AccompanyingType", name)
}

// MarshalText implements the text marshaller method
func (x AccompanyingType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AccompanyingType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAccompanyingType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// CategoryTypeAreaGroup is a CategoryType of type AreaGroup
	CategoryTypeAreaGroup CategoryType = iota + 1
	// CategoryTypeArea is a CategoryType of type Area
	CategoryTypeArea
	// CategoryTypeSubArea is a CategoryType of type SubArea
	CategoryTypeSubArea
	// CategoryTypeSubSubArea is a CategoryType of type SubSubArea
	CategoryTypeSubSubArea
	// CategoryTypeTheme is a CategoryType of type Theme
	CategoryTypeTheme
)

const _CategoryTypeName = "AreaGroupAreaSubAreaSubSubAreaTheme"

var _CategoryTypeMap = map[CategoryType]string{
	1: _CategoryTypeName[0:9],
	2: _CategoryTypeName[9:13],
	3: _CategoryTypeName[13:20],
	4: _CategoryTypeName[20:30],
	5: _CategoryTypeName[30:35],
}

// String implements the Stringer interface.
func (x CategoryType) String() string {
	if str, ok := _CategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CategoryType(%d)", x)
}

var _CategoryTypeValue = map[string]CategoryType{
	_CategoryTypeName[0:9]:   1,
	_CategoryTypeName[9:13]:  2,
	_CategoryTypeName[13:20]: 3,
	_CategoryTypeName[20:30]: 4,
	_CategoryTypeName[30:35]: 5,
}

// ParseCategoryType attempts to convert a string to a CategoryType
func ParseCategoryType(name string) (CategoryType, error) {
	if x, ok := _CategoryTypeValue[name]; ok {
		return x, nil
	}
	return CategoryType(0), fmt.Errorf("%s is not a valid CategoryType", name)
}

// MarshalText implements the text marshaller method
func (x CategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *CategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ContextKeyTransaction is a ContextKey of type Transaction
	ContextKeyTransaction ContextKey = iota + 1
)

const _ContextKeyName = "Transaction"

var _ContextKeyMap = map[ContextKey]string{
	1: _ContextKeyName[0:11],
}

// String implements the Stringer interface.
func (x ContextKey) String() string {
	if str, ok := _ContextKeyMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ContextKey(%d)", x)
}

var _ContextKeyValue = map[string]ContextKey{
	_ContextKeyName[0:11]: 1,
}

// ParseContextKey attempts to convert a string to a ContextKey
func ParseContextKey(name string) (ContextKey, error) {
	if x, ok := _ContextKeyValue[name]; ok {
		return x, nil
	}
	return ContextKey(0), fmt.Errorf("%s is not a valid ContextKey", name)
}

// MarshalText implements the text marshaller method
func (x ContextKey) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ContextKey) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseContextKey(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// GenderMale is a Gender of type Male
	GenderMale Gender = iota + 1
	// GenderFemale is a Gender of type Female
	GenderFemale
)

const _GenderName = "MaleFemale"

var _GenderMap = map[Gender]string{
	1: _GenderName[0:4],
	2: _GenderName[4:10],
}

// String implements the Stringer interface.
func (x Gender) String() string {
	if str, ok := _GenderMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Gender(%d)", x)
}

var _GenderValue = map[string]Gender{
	_GenderName[0:4]:  1,
	_GenderName[4:10]: 2,
}

// ParseGender attempts to convert a string to a Gender
func ParseGender(name string) (Gender, error) {
	if x, ok := _GenderValue[name]; ok {
		return x, nil
	}
	return Gender(0), fmt.Errorf("%s is not a valid Gender", name)
}

// MarshalText implements the text marshaller method
func (x Gender) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *Gender) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseGender(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MediaSortByNEW is a MediaSortBy of type NEW
	MediaSortByNEW MediaSortBy = iota + 1
	// MediaSortByRANKING is a MediaSortBy of type RANKING
	MediaSortByRANKING
)

const _MediaSortByName = "NEWRANKING"

var _MediaSortByMap = map[MediaSortBy]string{
	1: _MediaSortByName[0:3],
	2: _MediaSortByName[3:10],
}

// String implements the Stringer interface.
func (x MediaSortBy) String() string {
	if str, ok := _MediaSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MediaSortBy(%d)", x)
}

var _MediaSortByValue = map[string]MediaSortBy{
	_MediaSortByName[0:3]:  1,
	_MediaSortByName[3:10]: 2,
}

// ParseMediaSortBy attempts to convert a string to a MediaSortBy
func ParseMediaSortBy(name string) (MediaSortBy, error) {
	if x, ok := _MediaSortByValue[name]; ok {
		return x, nil
	}
	return MediaSortBy(0), fmt.Errorf("%s is not a valid MediaSortBy", name)
}

// MarshalText implements the text marshaller method
func (x MediaSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *MediaSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMediaSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReviewSortByNEW is a ReviewSortBy of type NEW
	ReviewSortByNEW ReviewSortBy = iota + 1
	// ReviewSortByRECOMMEND is a ReviewSortBy of type RECOMMEND
	ReviewSortByRECOMMEND
)

const _ReviewSortByName = "NEWRECOMMEND"

var _ReviewSortByMap = map[ReviewSortBy]string{
	1: _ReviewSortByName[0:3],
	2: _ReviewSortByName[3:12],
}

// String implements the Stringer interface.
func (x ReviewSortBy) String() string {
	if str, ok := _ReviewSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewSortBy(%d)", x)
}

var _ReviewSortByValue = map[string]ReviewSortBy{
	_ReviewSortByName[0:3]:  1,
	_ReviewSortByName[3:12]: 2,
}

// ParseReviewSortBy attempts to convert a string to a ReviewSortBy
func ParseReviewSortBy(name string) (ReviewSortBy, error) {
	if x, ok := _ReviewSortByValue[name]; ok {
		return x, nil
	}
	return ReviewSortBy(0), fmt.Errorf("%s is not a valid ReviewSortBy", name)
}

// MarshalText implements the text marshaller method
func (x ReviewSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReviewSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReviewSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SuggestionTypeArea is a SuggestionType of type Area
	SuggestionTypeArea SuggestionType = iota + 1
	// SuggestionTypeSubArea is a SuggestionType of type SubArea
	SuggestionTypeSubArea
	// SuggestionTypeSubSubArea is a SuggestionType of type SubSubArea
	SuggestionTypeSubSubArea
	// SuggestionTypeTouristSpot is a SuggestionType of type TouristSpot
	SuggestionTypeTouristSpot
	// SuggestionTypeHashTag is a SuggestionType of type HashTag
	SuggestionTypeHashTag
	// SuggestionTypeUser is a SuggestionType of type User
	SuggestionTypeUser
)

const _SuggestionTypeName = "AreaSubAreaSubSubAreaTouristSpotHashTagUser"

var _SuggestionTypeMap = map[SuggestionType]string{
	1: _SuggestionTypeName[0:4],
	2: _SuggestionTypeName[4:11],
	3: _SuggestionTypeName[11:21],
	4: _SuggestionTypeName[21:32],
	5: _SuggestionTypeName[32:39],
	6: _SuggestionTypeName[39:43],
}

// String implements the Stringer interface.
func (x SuggestionType) String() string {
	if str, ok := _SuggestionTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SuggestionType(%d)", x)
}

var _SuggestionTypeValue = map[string]SuggestionType{
	_SuggestionTypeName[0:4]:   1,
	_SuggestionTypeName[4:11]:  2,
	_SuggestionTypeName[11:21]: 3,
	_SuggestionTypeName[21:32]: 4,
	_SuggestionTypeName[32:39]: 5,
	_SuggestionTypeName[39:43]: 6,
}

// ParseSuggestionType attempts to convert a string to a SuggestionType
func ParseSuggestionType(name string) (SuggestionType, error) {
	if x, ok := _SuggestionTypeValue[name]; ok {
		return x, nil
	}
	return SuggestionType(0), fmt.Errorf("%s is not a valid SuggestionType", name)
}

// MarshalText implements the text marshaller method
func (x SuggestionType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SuggestionType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSuggestionType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserSortByRANKING is a UserSortBy of type RANKING
	UserSortByRANKING UserSortBy = iota + 1
	// UserSortByRECOMMEND is a UserSortBy of type RECOMMEND
	UserSortByRECOMMEND
)

const _UserSortByName = "RANKINGRECOMMEND"

var _UserSortByMap = map[UserSortBy]string{
	1: _UserSortByName[0:7],
	2: _UserSortByName[7:16],
}

// String implements the Stringer interface.
func (x UserSortBy) String() string {
	if str, ok := _UserSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserSortBy(%d)", x)
}

var _UserSortByValue = map[string]UserSortBy{
	_UserSortByName[0:7]:  1,
	_UserSortByName[7:16]: 2,
}

// ParseUserSortBy attempts to convert a string to a UserSortBy
func ParseUserSortBy(name string) (UserSortBy, error) {
	if x, ok := _UserSortByValue[name]; ok {
		return x, nil
	}
	return UserSortBy(0), fmt.Errorf("%s is not a valid UserSortBy", name)
}

// MarshalText implements the text marshaller method
func (x UserSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *UserSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUserSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
