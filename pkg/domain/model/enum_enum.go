// Code generated by go-enum
// DO NOT EDIT!

package model

import (
	"fmt"
)

const (
	// AccompanyingTypeBUSINESS is a AccompanyingType of type BUSINESS
	AccompanyingTypeBUSINESS AccompanyingType = iota + 1
	// AccompanyingTypeCOUPLE is a AccompanyingType of type COUPLE
	AccompanyingTypeCOUPLE
	// AccompanyingTypeFAMILY is a AccompanyingType of type FAMILY
	AccompanyingTypeFAMILY
	// AccompanyingTypeFRIEND is a AccompanyingType of type FRIEND
	AccompanyingTypeFRIEND
	// AccompanyingTypeONLY is a AccompanyingType of type ONLY
	AccompanyingTypeONLY
	// AccompanyingTypeWITHCHILD is a AccompanyingType of type WITHCHILD
	AccompanyingTypeWITHCHILD
)

const _AccompanyingTypeName = "BUSINESSCOUPLEFAMILYFRIENDONLYWITHCHILD"

var _AccompanyingTypeMap = map[AccompanyingType]string{
	1: _AccompanyingTypeName[0:8],
	2: _AccompanyingTypeName[8:14],
	3: _AccompanyingTypeName[14:20],
	4: _AccompanyingTypeName[20:26],
	5: _AccompanyingTypeName[26:30],
	6: _AccompanyingTypeName[30:39],
}

// String implements the Stringer interface.
func (x AccompanyingType) String() string {
	if str, ok := _AccompanyingTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AccompanyingType(%d)", x)
}

var _AccompanyingTypeValue = map[string]AccompanyingType{
	_AccompanyingTypeName[0:8]:   1,
	_AccompanyingTypeName[8:14]:  2,
	_AccompanyingTypeName[14:20]: 3,
	_AccompanyingTypeName[20:26]: 4,
	_AccompanyingTypeName[26:30]: 5,
	_AccompanyingTypeName[30:39]: 6,
}

// ParseAccompanyingType attempts to convert a string to a AccompanyingType
func ParseAccompanyingType(name string) (AccompanyingType, error) {
	if x, ok := _AccompanyingTypeValue[name]; ok {
		return x, nil
	}
	return AccompanyingType(0), fmt.Errorf("%s is not a valid AccompanyingType", name)
}

// MarshalText implements the text marshaller method
func (x AccompanyingType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AccompanyingType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAccompanyingType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// AreaCategoryTypeUndefined is a AreaCategoryType of type Undefined
	AreaCategoryTypeUndefined AreaCategoryType = iota
	// AreaCategoryTypeArea is a AreaCategoryType of type Area
	AreaCategoryTypeArea
	// AreaCategoryTypeSubArea is a AreaCategoryType of type SubArea
	AreaCategoryTypeSubArea
	// AreaCategoryTypeSubSubArea is a AreaCategoryType of type SubSubArea
	AreaCategoryTypeSubSubArea
)

const _AreaCategoryTypeName = "UndefinedAreaSubAreaSubSubArea"

var _AreaCategoryTypeMap = map[AreaCategoryType]string{
	0: _AreaCategoryTypeName[0:9],
	1: _AreaCategoryTypeName[9:13],
	2: _AreaCategoryTypeName[13:20],
	3: _AreaCategoryTypeName[20:30],
}

// String implements the Stringer interface.
func (x AreaCategoryType) String() string {
	if str, ok := _AreaCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AreaCategoryType(%d)", x)
}

var _AreaCategoryTypeValue = map[string]AreaCategoryType{
	_AreaCategoryTypeName[0:9]:   0,
	_AreaCategoryTypeName[9:13]:  1,
	_AreaCategoryTypeName[13:20]: 2,
	_AreaCategoryTypeName[20:30]: 3,
}

// ParseAreaCategoryType attempts to convert a string to a AreaCategoryType
func ParseAreaCategoryType(name string) (AreaCategoryType, error) {
	if x, ok := _AreaCategoryTypeValue[name]; ok {
		return x, nil
	}
	return AreaCategoryType(0), fmt.Errorf("%s is not a valid AreaCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x AreaCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AreaCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAreaCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// AreaGroupUndefined is a AreaGroup of type Undefined
	AreaGroupUndefined AreaGroup = iota
	// AreaGroupJapan is a AreaGroup of type Japan
	AreaGroupJapan
	// AreaGroupWorld is a AreaGroup of type World
	AreaGroupWorld
)

const _AreaGroupName = "UndefinedJapanWorld"

var _AreaGroupMap = map[AreaGroup]string{
	0: _AreaGroupName[0:9],
	1: _AreaGroupName[9:14],
	2: _AreaGroupName[14:19],
}

// String implements the Stringer interface.
func (x AreaGroup) String() string {
	if str, ok := _AreaGroupMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AreaGroup(%d)", x)
}

var _AreaGroupValue = map[string]AreaGroup{
	_AreaGroupName[0:9]:   0,
	_AreaGroupName[9:14]:  1,
	_AreaGroupName[14:19]: 2,
}

// ParseAreaGroup attempts to convert a string to a AreaGroup
func ParseAreaGroup(name string) (AreaGroup, error) {
	if x, ok := _AreaGroupValue[name]; ok {
		return x, nil
	}
	return AreaGroup(0), fmt.Errorf("%s is not a valid AreaGroup", name)
}

// MarshalText implements the text marshaller method
func (x AreaGroup) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AreaGroup) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAreaGroup(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// BatchOptionNameImportFacebookShareCountLastPostID is a BatchOptionName of type ImportFacebookShareCountLastPostID
	BatchOptionNameImportFacebookShareCountLastPostID BatchOptionName = iota
	// BatchOptionNameImportFacebookShareCountLastVlogID is a BatchOptionName of type ImportFacebookShareCountLastVlogID
	BatchOptionNameImportFacebookShareCountLastVlogID
	// BatchOptionNameImportFacebookShareCountLastCfProjectID is a BatchOptionName of type ImportFacebookShareCountLastCfProjectID
	BatchOptionNameImportFacebookShareCountLastCfProjectID
)

const _BatchOptionNameName = "ImportFacebookShareCountLastPostIDImportFacebookShareCountLastVlogIDImportFacebookShareCountLastCfProjectID"

var _BatchOptionNameMap = map[BatchOptionName]string{
	0: _BatchOptionNameName[0:34],
	1: _BatchOptionNameName[34:68],
	2: _BatchOptionNameName[68:107],
}

// String implements the Stringer interface.
func (x BatchOptionName) String() string {
	if str, ok := _BatchOptionNameMap[x]; ok {
		return str
	}
	return fmt.Sprintf("BatchOptionName(%d)", x)
}

var _BatchOptionNameValue = map[string]BatchOptionName{
	_BatchOptionNameName[0:34]:   0,
	_BatchOptionNameName[34:68]:  1,
	_BatchOptionNameName[68:107]: 2,
}

// ParseBatchOptionName attempts to convert a string to a BatchOptionName
func ParseBatchOptionName(name string) (BatchOptionName, error) {
	if x, ok := _BatchOptionNameValue[name]; ok {
		return x, nil
	}
	return BatchOptionName(0), fmt.Errorf("%s is not a valid BatchOptionName", name)
}

// MarshalText implements the text marshaller method
func (x BatchOptionName) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *BatchOptionName) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseBatchOptionName(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// CfProjectSortByNew is a CfProjectSortBy of type New
	CfProjectSortByNew CfProjectSortBy = iota
	// CfProjectSortByLargeAmount is a CfProjectSortBy of type LargeAmount
	CfProjectSortByLargeAmount
	// CfProjectSortByPush is a CfProjectSortBy of type Push
	CfProjectSortByPush
	// CfProjectSortByAttention is a CfProjectSortBy of type Attention
	CfProjectSortByAttention
)

const _CfProjectSortByName = "NewLargeAmountPushAttention"

var _CfProjectSortByMap = map[CfProjectSortBy]string{
	0: _CfProjectSortByName[0:3],
	1: _CfProjectSortByName[3:14],
	2: _CfProjectSortByName[14:18],
	3: _CfProjectSortByName[18:27],
}

// String implements the Stringer interface.
func (x CfProjectSortBy) String() string {
	if str, ok := _CfProjectSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CfProjectSortBy(%d)", x)
}

var _CfProjectSortByValue = map[string]CfProjectSortBy{
	_CfProjectSortByName[0:3]:   0,
	_CfProjectSortByName[3:14]:  1,
	_CfProjectSortByName[14:18]: 2,
	_CfProjectSortByName[18:27]: 3,
}

// ParseCfProjectSortBy attempts to convert a string to a CfProjectSortBy
func ParseCfProjectSortBy(name string) (CfProjectSortBy, error) {
	if x, ok := _CfProjectSortByValue[name]; ok {
		return x, nil
	}
	return CfProjectSortBy(0), fmt.Errorf("%s is not a valid CfProjectSortBy", name)
}

// MarshalText implements the text marshaller method
func (x CfProjectSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *CfProjectSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCfProjectSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// CfReturnGiftTypeReservedTicket is a CfReturnGiftType of type ReservedTicket
	CfReturnGiftTypeReservedTicket CfReturnGiftType = iota + 1
	// CfReturnGiftTypeOther is a CfReturnGiftType of type Other
	CfReturnGiftTypeOther
)

const _CfReturnGiftTypeName = "ReservedTicketOther"

var _CfReturnGiftTypeMap = map[CfReturnGiftType]string{
	1: _CfReturnGiftTypeName[0:14],
	2: _CfReturnGiftTypeName[14:19],
}

// String implements the Stringer interface.
func (x CfReturnGiftType) String() string {
	if str, ok := _CfReturnGiftTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CfReturnGiftType(%d)", x)
}

var _CfReturnGiftTypeValue = map[string]CfReturnGiftType{
	_CfReturnGiftTypeName[0:14]:  1,
	_CfReturnGiftTypeName[14:19]: 2,
}

// ParseCfReturnGiftType attempts to convert a string to a CfReturnGiftType
func ParseCfReturnGiftType(name string) (CfReturnGiftType, error) {
	if x, ok := _CfReturnGiftTypeValue[name]; ok {
		return x, nil
	}
	return CfReturnGiftType(0), fmt.Errorf("%s is not a valid CfReturnGiftType", name)
}

// MarshalText implements the text marshaller method
func (x CfReturnGiftType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *CfReturnGiftType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCfReturnGiftType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ContextKeyTransaction is a ContextKey of type Transaction
	ContextKeyTransaction ContextKey = iota + 1
)

const _ContextKeyName = "Transaction"

var _ContextKeyMap = map[ContextKey]string{
	1: _ContextKeyName[0:11],
}

// String implements the Stringer interface.
func (x ContextKey) String() string {
	if str, ok := _ContextKeyMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ContextKey(%d)", x)
}

var _ContextKeyValue = map[string]ContextKey{
	_ContextKeyName[0:11]: 1,
}

// ParseContextKey attempts to convert a string to a ContextKey
func ParseContextKey(name string) (ContextKey, error) {
	if x, ok := _ContextKeyValue[name]; ok {
		return x, nil
	}
	return ContextKey(0), fmt.Errorf("%s is not a valid ContextKey", name)
}

// MarshalText implements the text marshaller method
func (x ContextKey) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ContextKey) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseContextKey(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// EntityTypePost is a EntityType of type Post
	EntityTypePost EntityType = iota
	// EntityTypeVlog is a EntityType of type Vlog
	EntityTypeVlog
	// EntityTypeCfProject is a EntityType of type CfProject
	EntityTypeCfProject
	// EntityTypeReview is a EntityType of type Review
	EntityTypeReview
	// EntityTypeComic is a EntityType of type Comic
	EntityTypeComic
	// EntityTypeFeature is a EntityType of type Feature
	EntityTypeFeature
	// EntityTypeAll is a EntityType of type All
	EntityTypeAll
)

const _EntityTypeName = "PostVlogCfProjectReviewComicFeatureAll"

var _EntityTypeMap = map[EntityType]string{
	0: _EntityTypeName[0:4],
	1: _EntityTypeName[4:8],
	2: _EntityTypeName[8:17],
	3: _EntityTypeName[17:23],
	4: _EntityTypeName[23:28],
	5: _EntityTypeName[28:35],
	6: _EntityTypeName[35:38],
}

// String implements the Stringer interface.
func (x EntityType) String() string {
	if str, ok := _EntityTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("EntityType(%d)", x)
}

var _EntityTypeValue = map[string]EntityType{
	_EntityTypeName[0:4]:   0,
	_EntityTypeName[4:8]:   1,
	_EntityTypeName[8:17]:  2,
	_EntityTypeName[17:23]: 3,
	_EntityTypeName[23:28]: 4,
	_EntityTypeName[28:35]: 5,
	_EntityTypeName[35:38]: 6,
}

// ParseEntityType attempts to convert a string to a EntityType
func ParseEntityType(name string) (EntityType, error) {
	if x, ok := _EntityTypeValue[name]; ok {
		return x, nil
	}
	return EntityType(0), fmt.Errorf("%s is not a valid EntityType", name)
}

// MarshalText implements the text marshaller method
func (x EntityType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *EntityType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseEntityType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// GenderUndefined is a Gender of type Undefined
	GenderUndefined Gender = iota
	// GenderMale is a Gender of type Male
	GenderMale
	// GenderFemale is a Gender of type Female
	GenderFemale
)

const _GenderName = "UndefinedMaleFemale"

var _GenderMap = map[Gender]string{
	0: _GenderName[0:9],
	1: _GenderName[9:13],
	2: _GenderName[13:19],
}

// String implements the Stringer interface.
func (x Gender) String() string {
	if str, ok := _GenderMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Gender(%d)", x)
}

var _GenderValue = map[string]Gender{
	_GenderName[0:9]:   0,
	_GenderName[9:13]:  1,
	_GenderName[13:19]: 2,
}

// ParseGender attempts to convert a string to a Gender
func ParseGender(name string) (Gender, error) {
	if x, ok := _GenderValue[name]; ok {
		return x, nil
	}
	return Gender(0), fmt.Errorf("%s is not a valid Gender", name)
}

// MarshalText implements the text marshaller method
func (x Gender) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *Gender) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseGender(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// InterestGroupUndefined is a InterestGroup of type Undefined
	InterestGroupUndefined InterestGroup = iota
	// InterestGroupStyle is a InterestGroup of type Style
	InterestGroupStyle
	// InterestGroupScene is a InterestGroup of type Scene
	InterestGroupScene
	// InterestGroupGourmet is a InterestGroup of type Gourmet
	InterestGroupGourmet
	// InterestGroupLifeStyle is a InterestGroup of type LifeStyle
	InterestGroupLifeStyle
	// InterestGroupActivity is a InterestGroup of type Activity
	InterestGroupActivity
	// InterestGroupSport is a InterestGroup of type Sport
	InterestGroupSport
)

const _InterestGroupName = "UndefinedStyleSceneGourmetLifeStyleActivitySport"

var _InterestGroupMap = map[InterestGroup]string{
	0: _InterestGroupName[0:9],
	1: _InterestGroupName[9:14],
	2: _InterestGroupName[14:19],
	3: _InterestGroupName[19:26],
	4: _InterestGroupName[26:35],
	5: _InterestGroupName[35:43],
	6: _InterestGroupName[43:48],
}

// String implements the Stringer interface.
func (x InterestGroup) String() string {
	if str, ok := _InterestGroupMap[x]; ok {
		return str
	}
	return fmt.Sprintf("InterestGroup(%d)", x)
}

var _InterestGroupValue = map[string]InterestGroup{
	_InterestGroupName[0:9]:   0,
	_InterestGroupName[9:14]:  1,
	_InterestGroupName[14:19]: 2,
	_InterestGroupName[19:26]: 3,
	_InterestGroupName[26:35]: 4,
	_InterestGroupName[35:43]: 5,
	_InterestGroupName[43:48]: 6,
}

// ParseInterestGroup attempts to convert a string to a InterestGroup
func ParseInterestGroup(name string) (InterestGroup, error) {
	if x, ok := _InterestGroupValue[name]; ok {
		return x, nil
	}
	return InterestGroup(0), fmt.Errorf("%s is not a valid InterestGroup", name)
}

// MarshalText implements the text marshaller method
func (x InterestGroup) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *InterestGroup) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseInterestGroup(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MailTemplateNameThanksPurchase is a MailTemplateName of type ThanksPurchase
	MailTemplateNameThanksPurchase MailTemplateName = iota + 1
	// MailTemplateNameThanksPurchaseForNonLoginUser is a MailTemplateName of type ThanksPurchaseForNonLoginUser
	MailTemplateNameThanksPurchaseForNonLoginUser
	// MailTemplateNameThanksPurchaseForOwner is a MailTemplateName of type ThanksPurchaseForOwner
	MailTemplateNameThanksPurchaseForOwner
	// MailTemplateNameDepositRequestForStayway is a MailTemplateName of type DepositRequestForStayway
	MailTemplateNameDepositRequestForStayway
	// MailTemplateNameCfReturnGiftShippingNotification is a MailTemplateName of type CfReturnGiftShippingNotification
	MailTemplateNameCfReturnGiftShippingNotification
	// MailTemplateNameReserveRequestForOwner is a MailTemplateName of type ReserveRequestForOwner
	MailTemplateNameReserveRequestForOwner
	// MailTemplateNameReserveRequestForUser is a MailTemplateName of type ReserveRequestForUser
	MailTemplateNameReserveRequestForUser
	// MailTemplateNameCfProjectAchievementNoticeForSupporter is a MailTemplateName of type CfProjectAchievementNoticeForSupporter
	MailTemplateNameCfProjectAchievementNoticeForSupporter
	// MailTemplateNameCfProjectPostNewReportNoticeForSupporter is a MailTemplateName of type CfProjectPostNewReportNoticeForSupporter
	MailTemplateNameCfProjectPostNewReportNoticeForSupporter
)

const _MailTemplateNameName = "ThanksPurchaseThanksPurchaseForNonLoginUserThanksPurchaseForOwnerDepositRequestForStaywayCfReturnGiftShippingNotificationReserveRequestForOwnerReserveRequestForUserCfProjectAchievementNoticeForSupporterCfProjectPostNewReportNoticeForSupporter"

var _MailTemplateNameMap = map[MailTemplateName]string{
	1: _MailTemplateNameName[0:14],
	2: _MailTemplateNameName[14:43],
	3: _MailTemplateNameName[43:65],
	4: _MailTemplateNameName[65:89],
	5: _MailTemplateNameName[89:121],
	6: _MailTemplateNameName[121:143],
	7: _MailTemplateNameName[143:164],
	8: _MailTemplateNameName[164:202],
	9: _MailTemplateNameName[202:242],
}

// String implements the Stringer interface.
func (x MailTemplateName) String() string {
	if str, ok := _MailTemplateNameMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MailTemplateName(%d)", x)
}

var _MailTemplateNameValue = map[string]MailTemplateName{
	_MailTemplateNameName[0:14]:    1,
	_MailTemplateNameName[14:43]:   2,
	_MailTemplateNameName[43:65]:   3,
	_MailTemplateNameName[65:89]:   4,
	_MailTemplateNameName[89:121]:  5,
	_MailTemplateNameName[121:143]: 6,
	_MailTemplateNameName[143:164]: 7,
	_MailTemplateNameName[164:202]: 8,
	_MailTemplateNameName[202:242]: 9,
}

// ParseMailTemplateName attempts to convert a string to a MailTemplateName
func ParseMailTemplateName(name string) (MailTemplateName, error) {
	if x, ok := _MailTemplateNameValue[name]; ok {
		return x, nil
	}
	return MailTemplateName(0), fmt.Errorf("%s is not a valid MailTemplateName", name)
}

// MarshalText implements the text marshaller method
func (x MailTemplateName) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *MailTemplateName) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMailTemplateName(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MediaSortByNEW is a MediaSortBy of type NEW
	MediaSortByNEW MediaSortBy = iota + 1
	// MediaSortByRANKING is a MediaSortBy of type RANKING
	MediaSortByRANKING
	// MediaSortByRECOMMEND is a MediaSortBy of type RECOMMEND
	MediaSortByRECOMMEND
)

const _MediaSortByName = "NEWRANKINGRECOMMEND"

var _MediaSortByMap = map[MediaSortBy]string{
	1: _MediaSortByName[0:3],
	2: _MediaSortByName[3:10],
	3: _MediaSortByName[10:19],
}

// String implements the Stringer interface.
func (x MediaSortBy) String() string {
	if str, ok := _MediaSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MediaSortBy(%d)", x)
}

var _MediaSortByValue = map[string]MediaSortBy{
	_MediaSortByName[0:3]:   1,
	_MediaSortByName[3:10]:  2,
	_MediaSortByName[10:19]: 3,
}

// ParseMediaSortBy attempts to convert a string to a MediaSortBy
func ParseMediaSortBy(name string) (MediaSortBy, error) {
	if x, ok := _MediaSortByValue[name]; ok {
		return x, nil
	}
	return MediaSortBy(0), fmt.Errorf("%s is not a valid MediaSortBy", name)
}

// MarshalText implements the text marshaller method
func (x MediaSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *MediaSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMediaSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MediaTypeUserIcon is a MediaType of type UserIcon
	MediaTypeUserIcon MediaType = iota + 1
	// MediaTypeUserHeader is a MediaType of type UserHeader
	MediaTypeUserHeader
	// MediaTypeReviewImage is a MediaType of type ReviewImage
	MediaTypeReviewImage
	// MediaTypeReviewVideo is a MediaType of type ReviewVideo
	MediaTypeReviewVideo
)

const _MediaTypeName = "UserIconUserHeaderReviewImageReviewVideo"

var _MediaTypeMap = map[MediaType]string{
	1: _MediaTypeName[0:8],
	2: _MediaTypeName[8:18],
	3: _MediaTypeName[18:29],
	4: _MediaTypeName[29:40],
}

// String implements the Stringer interface.
func (x MediaType) String() string {
	if str, ok := _MediaTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("MediaType(%d)", x)
}

var _MediaTypeValue = map[string]MediaType{
	_MediaTypeName[0:8]:   1,
	_MediaTypeName[8:18]:  2,
	_MediaTypeName[18:29]: 3,
	_MediaTypeName[29:40]: 4,
}

// ParseMediaType attempts to convert a string to a MediaType
func ParseMediaType(name string) (MediaType, error) {
	if x, ok := _MediaTypeValue[name]; ok {
		return x, nil
	}
	return MediaType(0), fmt.Errorf("%s is not a valid MediaType", name)
}

// MarshalText implements the text marshaller method
func (x MediaType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *MediaType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMediaType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NoticeActionTargetTypePOST is a NoticeActionTargetType of type POST
	NoticeActionTargetTypePOST NoticeActionTargetType = iota + 1
	// NoticeActionTargetTypeVLOG is a NoticeActionTargetType of type VLOG
	NoticeActionTargetTypeVLOG
	// NoticeActionTargetTypeREVIEW is a NoticeActionTargetType of type REVIEW
	NoticeActionTargetTypeREVIEW
	// NoticeActionTargetTypeCOMMENT is a NoticeActionTargetType of type COMMENT
	NoticeActionTargetTypeCOMMENT
	// NoticeActionTargetTypeREPLY is a NoticeActionTargetType of type REPLY
	NoticeActionTargetTypeREPLY
	// NoticeActionTargetTypeUSER is a NoticeActionTargetType of type USER
	NoticeActionTargetTypeUSER
	// NoticeActionTargetTypeCOMIC is a NoticeActionTargetType of type COMIC
	NoticeActionTargetTypeCOMIC
)

const _NoticeActionTargetTypeName = "POSTVLOGREVIEWCOMMENTREPLYUSERCOMIC"

var _NoticeActionTargetTypeMap = map[NoticeActionTargetType]string{
	1: _NoticeActionTargetTypeName[0:4],
	2: _NoticeActionTargetTypeName[4:8],
	3: _NoticeActionTargetTypeName[8:14],
	4: _NoticeActionTargetTypeName[14:21],
	5: _NoticeActionTargetTypeName[21:26],
	6: _NoticeActionTargetTypeName[26:30],
	7: _NoticeActionTargetTypeName[30:35],
}

// String implements the Stringer interface.
func (x NoticeActionTargetType) String() string {
	if str, ok := _NoticeActionTargetTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoticeActionTargetType(%d)", x)
}

var _NoticeActionTargetTypeValue = map[string]NoticeActionTargetType{
	_NoticeActionTargetTypeName[0:4]:   1,
	_NoticeActionTargetTypeName[4:8]:   2,
	_NoticeActionTargetTypeName[8:14]:  3,
	_NoticeActionTargetTypeName[14:21]: 4,
	_NoticeActionTargetTypeName[21:26]: 5,
	_NoticeActionTargetTypeName[26:30]: 6,
	_NoticeActionTargetTypeName[30:35]: 7,
}

// ParseNoticeActionTargetType attempts to convert a string to a NoticeActionTargetType
func ParseNoticeActionTargetType(name string) (NoticeActionTargetType, error) {
	if x, ok := _NoticeActionTargetTypeValue[name]; ok {
		return x, nil
	}
	return NoticeActionTargetType(0), fmt.Errorf("%s is not a valid NoticeActionTargetType", name)
}

// MarshalText implements the text marshaller method
func (x NoticeActionTargetType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *NoticeActionTargetType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoticeActionTargetType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NoticeActionTypeFAVORITE is a NoticeActionType of type FAVORITE
	NoticeActionTypeFAVORITE NoticeActionType = iota + 1
	// NoticeActionTypeCOMMENT is a NoticeActionType of type COMMENT
	NoticeActionTypeCOMMENT
	// NoticeActionTypeREPLY is a NoticeActionType of type REPLY
	NoticeActionTypeREPLY
	// NoticeActionTypeFOLLOW is a NoticeActionType of type FOLLOW
	NoticeActionTypeFOLLOW
	// NoticeActionTypeTAGGED is a NoticeActionType of type TAGGED
	NoticeActionTypeTAGGED
)

const _NoticeActionTypeName = "FAVORITECOMMENTREPLYFOLLOWTAGGED"

var _NoticeActionTypeMap = map[NoticeActionType]string{
	1: _NoticeActionTypeName[0:8],
	2: _NoticeActionTypeName[8:15],
	3: _NoticeActionTypeName[15:20],
	4: _NoticeActionTypeName[20:26],
	5: _NoticeActionTypeName[26:32],
}

// String implements the Stringer interface.
func (x NoticeActionType) String() string {
	if str, ok := _NoticeActionTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoticeActionType(%d)", x)
}

var _NoticeActionTypeValue = map[string]NoticeActionType{
	_NoticeActionTypeName[0:8]:   1,
	_NoticeActionTypeName[8:15]:  2,
	_NoticeActionTypeName[15:20]: 3,
	_NoticeActionTypeName[20:26]: 4,
	_NoticeActionTypeName[26:32]: 5,
}

// ParseNoticeActionType attempts to convert a string to a NoticeActionType
func ParseNoticeActionType(name string) (NoticeActionType, error) {
	if x, ok := _NoticeActionTypeValue[name]; ok {
		return x, nil
	}
	return NoticeActionType(0), fmt.Errorf("%s is not a valid NoticeActionType", name)
}

// MarshalText implements the text marshaller method
func (x NoticeActionType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *NoticeActionType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoticeActionType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// PaymentCfReturnGiftOtherTypeStatusUndefined is a PaymentCfReturnGiftOtherTypeStatus of type Undefined
	PaymentCfReturnGiftOtherTypeStatusUndefined PaymentCfReturnGiftOtherTypeStatus = iota
	// PaymentCfReturnGiftOtherTypeStatusOwnerUnconfirmed is a PaymentCfReturnGiftOtherTypeStatus of type OwnerUnconfirmed
	PaymentCfReturnGiftOtherTypeStatusOwnerUnconfirmed
	// PaymentCfReturnGiftOtherTypeStatusOwnerConfirmed is a PaymentCfReturnGiftOtherTypeStatus of type OwnerConfirmed
	PaymentCfReturnGiftOtherTypeStatusOwnerConfirmed
	// PaymentCfReturnGiftOtherTypeStatusCanceled is a PaymentCfReturnGiftOtherTypeStatus of type Canceled
	PaymentCfReturnGiftOtherTypeStatusCanceled
)

const _PaymentCfReturnGiftOtherTypeStatusName = "UndefinedOwnerUnconfirmedOwnerConfirmedCanceled"

var _PaymentCfReturnGiftOtherTypeStatusMap = map[PaymentCfReturnGiftOtherTypeStatus]string{
	0: _PaymentCfReturnGiftOtherTypeStatusName[0:9],
	1: _PaymentCfReturnGiftOtherTypeStatusName[9:25],
	2: _PaymentCfReturnGiftOtherTypeStatusName[25:39],
	3: _PaymentCfReturnGiftOtherTypeStatusName[39:47],
}

// String implements the Stringer interface.
func (x PaymentCfReturnGiftOtherTypeStatus) String() string {
	if str, ok := _PaymentCfReturnGiftOtherTypeStatusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PaymentCfReturnGiftOtherTypeStatus(%d)", x)
}

var _PaymentCfReturnGiftOtherTypeStatusValue = map[string]PaymentCfReturnGiftOtherTypeStatus{
	_PaymentCfReturnGiftOtherTypeStatusName[0:9]:   0,
	_PaymentCfReturnGiftOtherTypeStatusName[9:25]:  1,
	_PaymentCfReturnGiftOtherTypeStatusName[25:39]: 2,
	_PaymentCfReturnGiftOtherTypeStatusName[39:47]: 3,
}

// ParsePaymentCfReturnGiftOtherTypeStatus attempts to convert a string to a PaymentCfReturnGiftOtherTypeStatus
func ParsePaymentCfReturnGiftOtherTypeStatus(name string) (PaymentCfReturnGiftOtherTypeStatus, error) {
	if x, ok := _PaymentCfReturnGiftOtherTypeStatusValue[name]; ok {
		return x, nil
	}
	return PaymentCfReturnGiftOtherTypeStatus(0), fmt.Errorf("%s is not a valid PaymentCfReturnGiftOtherTypeStatus", name)
}

// MarshalText implements the text marshaller method
func (x PaymentCfReturnGiftOtherTypeStatus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *PaymentCfReturnGiftOtherTypeStatus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePaymentCfReturnGiftOtherTypeStatus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// PaymentCfReturnGiftReservedTicketTypeStatusUndefined is a PaymentCfReturnGiftReservedTicketTypeStatus of type Undefined
	PaymentCfReturnGiftReservedTicketTypeStatusUndefined PaymentCfReturnGiftReservedTicketTypeStatus = iota
	// PaymentCfReturnGiftReservedTicketTypeStatusUnreserved is a PaymentCfReturnGiftReservedTicketTypeStatus of type Unreserved
	PaymentCfReturnGiftReservedTicketTypeStatusUnreserved
	// PaymentCfReturnGiftReservedTicketTypeStatusReserved is a PaymentCfReturnGiftReservedTicketTypeStatus of type Reserved
	PaymentCfReturnGiftReservedTicketTypeStatusReserved
	// PaymentCfReturnGiftReservedTicketTypeStatusCanceled is a PaymentCfReturnGiftReservedTicketTypeStatus of type Canceled
	PaymentCfReturnGiftReservedTicketTypeStatusCanceled
	// PaymentCfReturnGiftReservedTicketTypeStatusExpired is a PaymentCfReturnGiftReservedTicketTypeStatus of type Expired
	PaymentCfReturnGiftReservedTicketTypeStatusExpired
)

const _PaymentCfReturnGiftReservedTicketTypeStatusName = "UndefinedUnreservedReservedCanceledExpired"

var _PaymentCfReturnGiftReservedTicketTypeStatusMap = map[PaymentCfReturnGiftReservedTicketTypeStatus]string{
	0: _PaymentCfReturnGiftReservedTicketTypeStatusName[0:9],
	1: _PaymentCfReturnGiftReservedTicketTypeStatusName[9:19],
	2: _PaymentCfReturnGiftReservedTicketTypeStatusName[19:27],
	3: _PaymentCfReturnGiftReservedTicketTypeStatusName[27:35],
	4: _PaymentCfReturnGiftReservedTicketTypeStatusName[35:42],
}

// String implements the Stringer interface.
func (x PaymentCfReturnGiftReservedTicketTypeStatus) String() string {
	if str, ok := _PaymentCfReturnGiftReservedTicketTypeStatusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PaymentCfReturnGiftReservedTicketTypeStatus(%d)", x)
}

var _PaymentCfReturnGiftReservedTicketTypeStatusValue = map[string]PaymentCfReturnGiftReservedTicketTypeStatus{
	_PaymentCfReturnGiftReservedTicketTypeStatusName[0:9]:   0,
	_PaymentCfReturnGiftReservedTicketTypeStatusName[9:19]:  1,
	_PaymentCfReturnGiftReservedTicketTypeStatusName[19:27]: 2,
	_PaymentCfReturnGiftReservedTicketTypeStatusName[27:35]: 3,
	_PaymentCfReturnGiftReservedTicketTypeStatusName[35:42]: 4,
}

// ParsePaymentCfReturnGiftReservedTicketTypeStatus attempts to convert a string to a PaymentCfReturnGiftReservedTicketTypeStatus
func ParsePaymentCfReturnGiftReservedTicketTypeStatus(name string) (PaymentCfReturnGiftReservedTicketTypeStatus, error) {
	if x, ok := _PaymentCfReturnGiftReservedTicketTypeStatusValue[name]; ok {
		return x, nil
	}
	return PaymentCfReturnGiftReservedTicketTypeStatus(0), fmt.Errorf("%s is not a valid PaymentCfReturnGiftReservedTicketTypeStatus", name)
}

// MarshalText implements the text marshaller method
func (x PaymentCfReturnGiftReservedTicketTypeStatus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *PaymentCfReturnGiftReservedTicketTypeStatus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsePaymentCfReturnGiftReservedTicketTypeStatus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportReasonTypeUnknown is a ReportReasonType of type Unknown
	ReportReasonTypeUnknown ReportReasonType = iota + 1
	// ReportReasonTypeSexual is a ReportReasonType of type Sexual
	ReportReasonTypeSexual
	// ReportReasonTypeCopyright is a ReportReasonType of type Copyright
	ReportReasonTypeCopyright
	// ReportReasonTypeSelfHarm is a ReportReasonType of type SelfHarm
	ReportReasonTypeSelfHarm
	// ReportReasonTypeLie is a ReportReasonType of type Lie
	ReportReasonTypeLie
	// ReportReasonTypeUnrelated is a ReportReasonType of type Unrelated
	ReportReasonTypeUnrelated
	// ReportReasonTypeAd is a ReportReasonType of type Ad
	ReportReasonTypeAd
)

const _ReportReasonTypeName = "UnknownSexualCopyrightSelfHarmLieUnrelatedAd"

var _ReportReasonTypeMap = map[ReportReasonType]string{
	1: _ReportReasonTypeName[0:7],
	2: _ReportReasonTypeName[7:13],
	3: _ReportReasonTypeName[13:22],
	4: _ReportReasonTypeName[22:30],
	5: _ReportReasonTypeName[30:33],
	6: _ReportReasonTypeName[33:42],
	7: _ReportReasonTypeName[42:44],
}

// String implements the Stringer interface.
func (x ReportReasonType) String() string {
	if str, ok := _ReportReasonTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportReasonType(%d)", x)
}

var _ReportReasonTypeValue = map[string]ReportReasonType{
	_ReportReasonTypeName[0:7]:   1,
	_ReportReasonTypeName[7:13]:  2,
	_ReportReasonTypeName[13:22]: 3,
	_ReportReasonTypeName[22:30]: 4,
	_ReportReasonTypeName[30:33]: 5,
	_ReportReasonTypeName[33:42]: 6,
	_ReportReasonTypeName[42:44]: 7,
}

// ParseReportReasonType attempts to convert a string to a ReportReasonType
func ParseReportReasonType(name string) (ReportReasonType, error) {
	if x, ok := _ReportReasonTypeValue[name]; ok {
		return x, nil
	}
	return ReportReasonType(0), fmt.Errorf("%s is not a valid ReportReasonType", name)
}

// MarshalText implements the text marshaller method
func (x ReportReasonType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReportReasonType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportReasonType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportTargetTypeReview is a ReportTargetType of type Review
	ReportTargetTypeReview ReportTargetType = iota + 1
	// ReportTargetTypeComment is a ReportTargetType of type Comment
	ReportTargetTypeComment
	// ReportTargetTypeReply is a ReportTargetType of type Reply
	ReportTargetTypeReply
	// ReportTargetTypeUser is a ReportTargetType of type User
	ReportTargetTypeUser
)

const _ReportTargetTypeName = "ReviewCommentReplyUser"

var _ReportTargetTypeMap = map[ReportTargetType]string{
	1: _ReportTargetTypeName[0:6],
	2: _ReportTargetTypeName[6:13],
	3: _ReportTargetTypeName[13:18],
	4: _ReportTargetTypeName[18:22],
}

// String implements the Stringer interface.
func (x ReportTargetType) String() string {
	if str, ok := _ReportTargetTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportTargetType(%d)", x)
}

var _ReportTargetTypeValue = map[string]ReportTargetType{
	_ReportTargetTypeName[0:6]:   1,
	_ReportTargetTypeName[6:13]:  2,
	_ReportTargetTypeName[13:18]: 3,
	_ReportTargetTypeName[18:22]: 4,
}

// ParseReportTargetType attempts to convert a string to a ReportTargetType
func ParseReportTargetType(name string) (ReportTargetType, error) {
	if x, ok := _ReportTargetTypeValue[name]; ok {
		return x, nil
	}
	return ReportTargetType(0), fmt.Errorf("%s is not a valid ReportTargetType", name)
}

// MarshalText implements the text marshaller method
func (x ReportTargetType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReportTargetType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportTargetType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReviewSortByNEW is a ReviewSortBy of type NEW
	ReviewSortByNEW ReviewSortBy = iota + 1
	// ReviewSortByRECOMMEND is a ReviewSortBy of type RECOMMEND
	ReviewSortByRECOMMEND
)

const _ReviewSortByName = "NEWRECOMMEND"

var _ReviewSortByMap = map[ReviewSortBy]string{
	1: _ReviewSortByName[0:3],
	2: _ReviewSortByName[3:12],
}

// String implements the Stringer interface.
func (x ReviewSortBy) String() string {
	if str, ok := _ReviewSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewSortBy(%d)", x)
}

var _ReviewSortByValue = map[string]ReviewSortBy{
	_ReviewSortByName[0:3]:  1,
	_ReviewSortByName[3:12]: 2,
}

// ParseReviewSortBy attempts to convert a string to a ReviewSortBy
func ParseReviewSortBy(name string) (ReviewSortBy, error) {
	if x, ok := _ReviewSortByValue[name]; ok {
		return x, nil
	}
	return ReviewSortBy(0), fmt.Errorf("%s is not a valid ReviewSortBy", name)
}

// MarshalText implements the text marshaller method
func (x ReviewSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReviewSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReviewSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReviewTargetUndefined is a ReviewTarget of type Undefined
	ReviewTargetUndefined ReviewTarget = iota
	// ReviewTargetInn is a ReviewTarget of type Inn
	ReviewTargetInn
	// ReviewTargetTouristSpot is a ReviewTarget of type TouristSpot
	ReviewTargetTouristSpot
)

const _ReviewTargetName = "UndefinedInnTouristSpot"

var _ReviewTargetMap = map[ReviewTarget]string{
	0: _ReviewTargetName[0:9],
	1: _ReviewTargetName[9:12],
	2: _ReviewTargetName[12:23],
}

// String implements the Stringer interface.
func (x ReviewTarget) String() string {
	if str, ok := _ReviewTargetMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewTarget(%d)", x)
}

var _ReviewTargetValue = map[string]ReviewTarget{
	_ReviewTargetName[0:9]:   0,
	_ReviewTargetName[9:12]:  1,
	_ReviewTargetName[12:23]: 2,
}

// ParseReviewTarget attempts to convert a string to a ReviewTarget
func ParseReviewTarget(name string) (ReviewTarget, error) {
	if x, ok := _ReviewTargetValue[name]; ok {
		return x, nil
	}
	return ReviewTarget(0), fmt.Errorf("%s is not a valid ReviewTarget", name)
}

// MarshalText implements the text marshaller method
func (x ReviewTarget) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ReviewTarget) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReviewTarget(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SessionStatusUndefined is a SessionStatus of type Undefined
	SessionStatusUndefined SessionStatus = iota
	// SessionStatusInSession is a SessionStatus of type InSession
	SessionStatusInSession
)

const _SessionStatusName = "UndefinedInSession"

var _SessionStatusMap = map[SessionStatus]string{
	0: _SessionStatusName[0:9],
	1: _SessionStatusName[9:18],
}

// String implements the Stringer interface.
func (x SessionStatus) String() string {
	if str, ok := _SessionStatusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SessionStatus(%d)", x)
}

var _SessionStatusValue = map[string]SessionStatus{
	_SessionStatusName[0:9]:  0,
	_SessionStatusName[9:18]: 1,
}

// ParseSessionStatus attempts to convert a string to a SessionStatus
func ParseSessionStatus(name string) (SessionStatus, error) {
	if x, ok := _SessionStatusValue[name]; ok {
		return x, nil
	}
	return SessionStatus(0), fmt.Errorf("%s is not a valid SessionStatus", name)
}

// MarshalText implements the text marshaller method
func (x SessionStatus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SessionStatus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSessionStatus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SpotCategoryTypeUndefined is a SpotCategoryType of type Undefined
	SpotCategoryTypeUndefined SpotCategoryType = iota
	// SpotCategoryTypeSpotCategory is a SpotCategoryType of type SpotCategory
	SpotCategoryTypeSpotCategory
	// SpotCategoryTypeSubSpotCategory is a SpotCategoryType of type SubSpotCategory
	SpotCategoryTypeSubSpotCategory
)

const _SpotCategoryTypeName = "UndefinedSpotCategorySubSpotCategory"

var _SpotCategoryTypeMap = map[SpotCategoryType]string{
	0: _SpotCategoryTypeName[0:9],
	1: _SpotCategoryTypeName[9:21],
	2: _SpotCategoryTypeName[21:36],
}

// String implements the Stringer interface.
func (x SpotCategoryType) String() string {
	if str, ok := _SpotCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SpotCategoryType(%d)", x)
}

var _SpotCategoryTypeValue = map[string]SpotCategoryType{
	_SpotCategoryTypeName[0:9]:   0,
	_SpotCategoryTypeName[9:21]:  1,
	_SpotCategoryTypeName[21:36]: 2,
}

// ParseSpotCategoryType attempts to convert a string to a SpotCategoryType
func ParseSpotCategoryType(name string) (SpotCategoryType, error) {
	if x, ok := _SpotCategoryTypeValue[name]; ok {
		return x, nil
	}
	return SpotCategoryType(0), fmt.Errorf("%s is not a valid SpotCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x SpotCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SpotCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSpotCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SuggestionTypeArea is a SuggestionType of type Area
	SuggestionTypeArea SuggestionType = iota + 1
	// SuggestionTypeSubArea is a SuggestionType of type SubArea
	SuggestionTypeSubArea
	// SuggestionTypeSubSubArea is a SuggestionType of type SubSubArea
	SuggestionTypeSubSubArea
	// SuggestionTypeTouristSpot is a SuggestionType of type TouristSpot
	SuggestionTypeTouristSpot
	// SuggestionTypeHashTag is a SuggestionType of type HashTag
	SuggestionTypeHashTag
	// SuggestionTypeUser is a SuggestionType of type User
	SuggestionTypeUser
)

const _SuggestionTypeName = "AreaSubAreaSubSubAreaTouristSpotHashTagUser"

var _SuggestionTypeMap = map[SuggestionType]string{
	1: _SuggestionTypeName[0:4],
	2: _SuggestionTypeName[4:11],
	3: _SuggestionTypeName[11:21],
	4: _SuggestionTypeName[21:32],
	5: _SuggestionTypeName[32:39],
	6: _SuggestionTypeName[39:43],
}

// String implements the Stringer interface.
func (x SuggestionType) String() string {
	if str, ok := _SuggestionTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SuggestionType(%d)", x)
}

var _SuggestionTypeValue = map[string]SuggestionType{
	_SuggestionTypeName[0:4]:   1,
	_SuggestionTypeName[4:11]:  2,
	_SuggestionTypeName[11:21]: 3,
	_SuggestionTypeName[21:32]: 4,
	_SuggestionTypeName[32:39]: 5,
	_SuggestionTypeName[39:43]: 6,
}

// ParseSuggestionType attempts to convert a string to a SuggestionType
func ParseSuggestionType(name string) (SuggestionType, error) {
	if x, ok := _SuggestionTypeValue[name]; ok {
		return x, nil
	}
	return SuggestionType(0), fmt.Errorf("%s is not a valid SuggestionType", name)
}

// MarshalText implements the text marshaller method
func (x SuggestionType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *SuggestionType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSuggestionType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ThemeCategoryTypeUndefined is a ThemeCategoryType of type Undefined
	ThemeCategoryTypeUndefined ThemeCategoryType = iota
	// ThemeCategoryTypeTheme is a ThemeCategoryType of type Theme
	ThemeCategoryTypeTheme
	// ThemeCategoryTypeSubTheme is a ThemeCategoryType of type SubTheme
	ThemeCategoryTypeSubTheme
)

const _ThemeCategoryTypeName = "UndefinedThemeSubTheme"

var _ThemeCategoryTypeMap = map[ThemeCategoryType]string{
	0: _ThemeCategoryTypeName[0:9],
	1: _ThemeCategoryTypeName[9:14],
	2: _ThemeCategoryTypeName[14:22],
}

// String implements the Stringer interface.
func (x ThemeCategoryType) String() string {
	if str, ok := _ThemeCategoryTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ThemeCategoryType(%d)", x)
}

var _ThemeCategoryTypeValue = map[string]ThemeCategoryType{
	_ThemeCategoryTypeName[0:9]:   0,
	_ThemeCategoryTypeName[9:14]:  1,
	_ThemeCategoryTypeName[14:22]: 2,
}

// ParseThemeCategoryType attempts to convert a string to a ThemeCategoryType
func ParseThemeCategoryType(name string) (ThemeCategoryType, error) {
	if x, ok := _ThemeCategoryTypeValue[name]; ok {
		return x, nil
	}
	return ThemeCategoryType(0), fmt.Errorf("%s is not a valid ThemeCategoryType", name)
}

// MarshalText implements the text marshaller method
func (x ThemeCategoryType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *ThemeCategoryType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseThemeCategoryType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserAttributeCommon is a UserAttribute of type Common
	UserAttributeCommon UserAttribute = iota + 1
	// UserAttributeWP is a UserAttribute of type WP
	UserAttributeWP
	// UserAttributeCfProjectOwner is a UserAttribute of type CfProjectOwner
	UserAttributeCfProjectOwner
	// UserAttributeCfProjectAdmin is a UserAttribute of type CfProjectAdmin
	UserAttributeCfProjectAdmin
)

const _UserAttributeName = "CommonWPCfProjectOwnerCfProjectAdmin"

var _UserAttributeMap = map[UserAttribute]string{
	1: _UserAttributeName[0:6],
	2: _UserAttributeName[6:8],
	3: _UserAttributeName[8:22],
	4: _UserAttributeName[22:36],
}

// String implements the Stringer interface.
func (x UserAttribute) String() string {
	if str, ok := _UserAttributeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserAttribute(%d)", x)
}

var _UserAttributeValue = map[string]UserAttribute{
	_UserAttributeName[0:6]:   1,
	_UserAttributeName[6:8]:   2,
	_UserAttributeName[8:22]:  3,
	_UserAttributeName[22:36]: 4,
}

// ParseUserAttribute attempts to convert a string to a UserAttribute
func ParseUserAttribute(name string) (UserAttribute, error) {
	if x, ok := _UserAttributeValue[name]; ok {
		return x, nil
	}
	return UserAttribute(0), fmt.Errorf("%s is not a valid UserAttribute", name)
}

// MarshalText implements the text marshaller method
func (x UserAttribute) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *UserAttribute) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUserAttribute(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserSalesReasonTypeAvailable is a UserSalesReasonType of type Available
	UserSalesReasonTypeAvailable UserSalesReasonType = iota + 1
	// UserSalesReasonTypeUnavailable is a UserSalesReasonType of type Unavailable
	UserSalesReasonTypeUnavailable
	// UserSalesReasonTypeDone is a UserSalesReasonType of type Done
	UserSalesReasonTypeDone
)

const _UserSalesReasonTypeName = "AvailableUnavailableDone"

var _UserSalesReasonTypeMap = map[UserSalesReasonType]string{
	1: _UserSalesReasonTypeName[0:9],
	2: _UserSalesReasonTypeName[9:20],
	3: _UserSalesReasonTypeName[20:24],
}

// String implements the Stringer interface.
func (x UserSalesReasonType) String() string {
	if str, ok := _UserSalesReasonTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserSalesReasonType(%d)", x)
}

var _UserSalesReasonTypeValue = map[string]UserSalesReasonType{
	_UserSalesReasonTypeName[0:9]:   1,
	_UserSalesReasonTypeName[9:20]:  2,
	_UserSalesReasonTypeName[20:24]: 3,
}

// ParseUserSalesReasonType attempts to convert a string to a UserSalesReasonType
func ParseUserSalesReasonType(name string) (UserSalesReasonType, error) {
	if x, ok := _UserSalesReasonTypeValue[name]; ok {
		return x, nil
	}
	return UserSalesReasonType(0), fmt.Errorf("%s is not a valid UserSalesReasonType", name)
}

// MarshalText implements the text marshaller method
func (x UserSalesReasonType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *UserSalesReasonType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUserSalesReasonType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserSortByRANKING is a UserSortBy of type RANKING
	UserSortByRANKING UserSortBy = iota + 1
	// UserSortByRECOMMEND is a UserSortBy of type RECOMMEND
	UserSortByRECOMMEND
)

const _UserSortByName = "RANKINGRECOMMEND"

var _UserSortByMap = map[UserSortBy]string{
	1: _UserSortByName[0:7],
	2: _UserSortByName[7:16],
}

// String implements the Stringer interface.
func (x UserSortBy) String() string {
	if str, ok := _UserSortByMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserSortBy(%d)", x)
}

var _UserSortByValue = map[string]UserSortBy{
	_UserSortByName[0:7]:  1,
	_UserSortByName[7:16]: 2,
}

// ParseUserSortBy attempts to convert a string to a UserSortBy
func ParseUserSortBy(name string) (UserSortBy, error) {
	if x, ok := _UserSortByValue[name]; ok {
		return x, nil
	}
	return UserSortBy(0), fmt.Errorf("%s is not a valid UserSortBy", name)
}

// MarshalText implements the text marshaller method
func (x UserSortBy) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *UserSortBy) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUserSortBy(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
